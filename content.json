{"meta":{"title":"一半是火一半是光的博客","subtitle":"","description":"给自己的知识一片栖息之地","author":"chh3213","url":"https://chh3213.github.io","root":"/"},"pages":[{"title":"关于CHH","date":"2022-10-27T06:49:42.863Z","updated":"2022-10-27T06:49:42.863Z","comments":true,"path":"about.html","permalink":"https://chh3213.github.io/about.html","excerpt":"","text":"👋 Hi, I’m @CHH3213 👀 I’m interested in Reinforcement Learning and Self-Driving 🌱 I’m currently learning RL, Python, C++, Control Theory… 📫 Reach me through chh3213@foxmail.com 但行好事，莫问前程! 自己并非是什么独一无二的人，只是一个普通人，要牢记三点： 要保持健康的状态； 不断提升自己的专业能力； 谨慎投资，不要想着能够暴富！ 时刻关注自己的成长和进步。"},{"title":"文章归档","date":"2022-06-11T13:15:27.244Z","updated":"2022-06-11T13:15:27.244Z","comments":true,"path":"archive.html","permalink":"https://chh3213.github.io/archive.html","excerpt":"","text":""},{"title":"我的学习之路","date":"2022-10-27T06:24:24.314Z","updated":"2022-10-27T06:24:24.314Z","comments":true,"path":"study/index.html","permalink":"https://chh3213.github.io/study/index.html","excerpt":"","text":"欢迎访问我的CSDN博客主页。 学习项目我的github主页上以chh开头的仓库均为学习项目. 学习项目 项目名称 说明 chhCpp 学习C++仓库 java_learning 学习Java仓库 chhPython 学习Python仓库 chhRobotics 学习自动驾驶、控制理论相关仓库 chhML 学习机器学习仓库 chhRL 学习强化学习仓库 chhVim 学习vim操作仓库 chhDocker 学习docker仓库 chhShell 学习Shell仓库 chhROS 学习ROS仓库 chhTricks 存放一些有意思的tricks 总的路线图 编程编程部分主要聚焦于C++、python、数据结构与算法。 机器学习机器学习模块首先需要掌握机器学习和深度学习的基础知识，会搭建网络；进一步地掌握强化学习的基础知识和理论，会应用强化学习解决工程项目。 下面是总结的导图 自动驾驶 主要聚焦于决策控制这一块。 专业技能vim、docker等的掌握。"},{"title":"思维导图","date":"2021-04-17T14:41:51.000Z","updated":"2022-06-12T06:21:08.119Z","comments":true,"path":"xmind/index.html","permalink":"https://chh3213.github.io/xmind/index.html","excerpt":"","text":"Mind Map html, body { margin: 0; padding: 0; width: 100%; height: 100%; } 'use strict'; (function () { $(function () { $('.position').click(function (event) { var el = $(event.target); $('.position').removeClass('selected'); el.addClass('selected'); position = el.attr('data-position'); }); }); }); var position = 2; // 关闭百毫秒数 var closeTime = 50; var notifyFunc = function () { Notification.create( // Title \"欢迎使用思维导图✒️\", // Text \"思维导图操作说明：JMind使用手册\", // Illustration \"https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/component/思维导图/images/avatar4.jpg\", // Effect 'fadeInRight', // Position 1, 2, 3, 4 1, closeTime ); }; notifyFunc();"}],"posts":[{"title":"Github主页美化","slug":"Github主页美化","date":"2022-10-27T02:02:00.267Z","updated":"2022-10-27T02:02:00.268Z","comments":true,"path":"2022/10/27/Github主页美化/","link":"","permalink":"https://chh3213.github.io/2022/10/27/Github%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/","excerpt":"Github主页的展示效果总结。","text":"Github主页的展示效果总结。 添加Github状态实现效果如下： 配置地址见：https://github.com/anuraghazra/github-readme-stats 添加Github小图标如何添加下图所示的小图标呢？ 方法很简单： 找到这个网站主页：https://shields.io/，这其实就是一个设计图标的网站。 打开官网主页后，找到下述图中信息，直接填充好文字和信息，以及图标的颜色，点击Make Badge，就会生成这个图标的地址。 ​ 然后在Github主页插入即可。插入方式如下： 1[![](https://img.shields.io/badge/CHH3213-CSDN-red)](https://blog.csdn.net/weixin_42301220?spm=1010.2135.3001.5343) 前面的是图标地址，后面的是链接地址。 生成后的图标如下： 使用Wakatime记录你的Coding数据WakaTime 是一款可以记录你的编码时间的工具，目前支持绝大部分主流的 IDE 以及 Chrome 浏览器。 安装Wakatime 注册 WakaTime 账号； 在官网找到对应的 IDE 插件，按照步骤安装 WakaTime 插件； 在个人设置页面复制 Secret API Key ，填入对应的 WakaTime 插件中； 过一段时间后，你就可以在 WakaTime 网站上看到你的编码情况； 主页接入waka-boxwaka-box提供了你每周的代码状态，并且更新为类似于下面的内容： 下面是接入步骤： 获取 GitHub API 令牌， 打开 Settings / Developer settings / Personal access tokens 页面，创建 Github Token ，权限部分勾选repo、workflow和user。生成后将token保存下来 进入 WakaTime 配置页面，勾选 Display coding activity publicly 与 Display languages, editors, operating systems publicly 查看 WakaTime 账号 api-key，并保存好 项目设置 在你的Github 自定义首页的仓库，打开 Settings / Secrets / Actions 页面，点击 New repository secret 添加 Secret API Key 密钥，Name 为 WAKATIME_API_KEY ，value 为Secret API Key 密钥 添加 Secret API Key 密钥，Name 为 GH_TOKEN ，value 为GitHub API token 配置Github Action工作流 打开该仓库的 Actions 页面，点击 set up a workflow yourself 设置工作流 文件名随意，清空初始内容，添入如下配置 1234567891011121314151617181920212223242526name: Waka Readmeon:schedule: # Runs at 12am IST - cron: &#x27;30 18 ** *&#x27;workflow_dispatch:jobs:update-readme: name: Update Readme with Metrics runs-on: ubuntu-latest steps: - uses: anmol098/waka-readme-stats@master with: WAKATIME_API_KEY: $&#123;&#123; secrets.WAKATIME_API_KEY &#125;&#125; GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; SHOW_OS: &quot;False&quot; SHOW_PROJECTS: &quot;False&quot; SHOW_COMMIT: &quot;False&quot; SHOW_DAYS_OF_WEEK: &quot;False&quot; SHOW_TIMEZONE: &quot;False&quot; SHOW_EDITORS: &quot;False&quot; SHOW_SHORT_INFO: &quot;False&quot; SHOW_LOC_CHART: &quot;False&quot; SHOW_TOTAL_CODE_TIME: &quot;False&quot; SHOW_PROFILE_VIEWS: &quot;False&quot; 一些自定义配置可以在 waka-readme-stats 仓库中找到示例。 然后提交至仓库。 更新README.md文件，在需要展示的地方，添加如下代码，下面代码相当于占位符，生成后的数据统计会放置在这个位置之中。 12&lt;!--START_SECTION:waka--&gt;&lt;!--END_SECTION:waka--&gt; 点击该工作流，再点击Run workflow运行。 github actions 工作流是根据 .yml 配置文件定时运行任务，如果想马上看到结果，就需要手动执行一下 运行成功后可以点击当前的workflow进入查看执行日志。 以上配置完成后耐心等待数据同步到readme即可。 另外还可参考以下资料： https://blog.csdn.net/weixin_43233914/article/details/126087735 https://github.com/athul/waka-readme#extras https://github.com/anmol098/waka-readme-stats","categories":[{"name":"主页美化","slug":"主页美化","permalink":"https://chh3213.github.io/categories/%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"主页","slug":"主页","permalink":"https://chh3213.github.io/tags/%E4%B8%BB%E9%A1%B5/"}]},{"title":"Windows远程桌面工具连接Ubuntu系统","slug":"Windows远程桌面工具连接Ubuntu系统","date":"2022-10-18T06:32:01.000Z","updated":"2022-10-22T04:07:22.471Z","comments":true,"path":"2022/10/18/Windows远程桌面工具连接Ubuntu系统/","link":"","permalink":"https://chh3213.github.io/2022/10/18/Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5Ubuntu%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1. 前言1.1 常见远程桌面软件推荐随着过去一年多的研究生生涯，也陆陆续续用了几款远程桌面软件。目前来看都还不错。我主要用过的是4款：TeamViewer，RustDesk, 向日葵, ToDesk。这4款ubuntu和windows下均可使用。 4个软件的界面分别如下： 1.2 比较 其中，个人体验而言，TeamViewer，RustDesk,ToDesk是优于向日葵的。因为向日葵免费版不能够进行传输文件，剪贴板也不能共享（不能相互之间复制粘贴文字）。 速度而言，使用局域网时，体验上三者没有什么差别；不使用局域网连接时，向日葵速度&gt;TeamViewer&gt;RustDesk=ToDesk。所以，使用局域网时，还是推荐使用后三者的。不过可以自建服务器，不过我自己没有试过，还不懂咋搞。。。 使用向日葵可能会碰到的一个问题，就是远程连接Ubuntu时，一连接就秒断的问题。具体可参考这个。之前实验室的服务器就碰到了这个问题，折腾了很久都没解决，还差点把系统搞崩了，因此果断放弃在服务器上使用向日葵，转为使用后3种了。 2. 使用windows远程桌面连接ubuntu用过windows远程桌面连接的小伙伴们都知道，使用起来非常顺畅丝滑，界面清晰。但它只能在windows之间使用，远程连接ubutnu还需要进行一些配置。 2.1 安装xrdpXrdp 是一个微软远程桌面协议（RDP）的开源实现，它允许我们通过图形界面控制远程系统。这里使用RDP而不是VNC作为远程桌面，是因为Windows自带的远程桌面连接软件用的就是RDP协议，RDP在Windows下的体验非常好，包括速度很快（因为压缩方案做得比较好），可以直接在主机和远程桌面之间复制粘贴等等。 有的Xwindow软件是不太兼容xrdp的（比如ubuntu 18.04的默认桌面），但是ubuntu 20.04使用的Gnome是完全ok的。 安装过程如下： 1sudo apt install xrdp 安装完成xrdp 服务将会自动启动，可以输入下面的命令验证它： 1sudo systemctl status xrdp 可以将xrdp设为开机启动1sudo systemctl enable xrdp 默认情况下，xrdp 使用/etc/ssl/private/ssl-cert-snakeoil.key，它仅仅对ssl-cert用户组成语可读，所以需要运行下面的命令，将xrdp用户添加到这个用户组： 12sudo adduser xrdp ssl-cert sudo systemctl restart xrdp 然后使用Windows自带的远程桌面软件连接服务器IP地址或者域名就行了。 2.2 问题1：远程连接后出现黑屏==连接远程桌面输入账户和密码后，进入ubuntu20.04后，如果出现的是黑屏==，","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Remote","slug":"Remote","permalink":"https://chh3213.github.io/tags/Remote/"}]},{"title":"内网穿透工具——cpolar","slug":"内网穿透工具——cpolar","date":"2022-10-15T12:16:58.000Z","updated":"2022-10-25T07:16:57.826Z","comments":true,"path":"2022/10/15/内网穿透工具——cpolar/","link":"","permalink":"https://chh3213.github.io/2022/10/15/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94cpolar/","excerpt":"在之前介绍了SakuraFrp内网穿透工具，后来又发现了一个也比较好的内网穿透工具cpolar。","text":"在之前介绍了SakuraFrp内网穿透工具，后来又发现了一个也比较好的内网穿透工具cpolar。 打开官网后直接选择对应版本下载安装即可。 下面介绍windows下和ubuntu的安装。 ☺️windows 被控端安装在官网注册好账号后，到官方界面下载对应的安装包，解压后默认安装即可。cpolar安装后会默认安装两条样例隧道: 一个是Website隧道，指向http 8080端口 一个是远程桌面隧道（win系统），指向tcp 3389端口 因此，我们安装完成后，只需要启动远程桌面隧道服务，就可以获得公网地址。 浏览器访问127.0.0.1:9200，登录cpolar web-ui管理界面。点击左侧仪表盘——隧道管理——隧道列表，找到远程桌面隧道，点击启动该隧道 隧道启动成功后，点击左侧仪表盘——状态——在线隧道列表，找到远程桌面隧道，可以看到已经有生成了相应的公网地址，复制下来。 安装完成后，在另外一台windows电脑进行远程桌面连接，填入刚才生成的公网TCP端口地址（是tcp://后面的地址），就可以实现内网穿透远程桌面连接。 ☺️linux被控端安装当服务器为linux系统时，我们可以通过SSH远程连接，同样正常在服务器安装cpolar客户端，然后映射内网端口即可。 linux系统官网已经给了一键自动安装脚本 国内使用 1curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 国外使用 1curl -sL https://git.io/cpolar | sudo bash 注意root权限问题。 安装完成后，登录账号查看认证的token： 然后终端输入：1cpolar authtoken 输入token数字xxxxxxxxxxxxxxxxxx 如果需要配置cpolar开机自启动: 1sudo systemctl enable cpolar 启动服务时输入命令： 1sudo systemctl start cpolar 通过查看服务状态来检查是否启动成功： 1sudo systemctl status cpolar 如显示active，则说明已经启动成功。 关闭命令： 1sudo systemctl stop cpolar cpolar 卸载方法 1curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash -s -- --remove 1234cpolar默认安装路径 /usr/local/bin/cpolar,安装脚本会自动配置systemd服务脚本，启动以后，可以开机自启动。如果第一次安装，会默认配置一个简单的样例配置文件，创建了两个样例隧道，一个web，一个sshcpolar配置文件路径: /usr/local/etc/cpolar/cpolar.yml 启动成功后，登录cpolar官网后台查看状态，可以查看到所有在线隧道的公网地址，找到SSH隧道的公网地址，复制下来。 然后就可以使用ssh相关工具通过公网ip登录了。1ssh username@公网地址 -p 端口号如1ssh pi@1.tcp.vip.cpolar.cn -p 20013由于我们的本地22端口到了公网被映射到了20013端口，所以，ssh命令需要加-p参数，后面加公网隧道端口号。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://chh3213.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"内网穿透工具——SakuraFrp","slug":"SakuraFrp内网穿透工具","date":"2022-10-15T04:04:44.000Z","updated":"2022-10-28T12:20:52.904Z","comments":true,"path":"2022/10/15/SakuraFrp内网穿透工具/","link":"","permalink":"https://chh3213.github.io/2022/10/15/SakuraFrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/","excerpt":"SakuraFrp是一个内网穿透工具，使用它就可以轻松的实现在不是同一个局域网下的远程连接☺️。","text":"SakuraFrp是一个内网穿透工具，使用它就可以轻松的实现在不是同一个局域网下的远程连接☺️。 😋SakuraFrp简单介绍内网穿透的基本原理可以戳此处。 😋被控端电脑接入步骤😉Sakura frp账号注册首先在官网注册Sakura frp账号。注册完成后需要进行实名认证: 点击首页的这个地方可以查看访问密钥，这个密钥待会用得上，不能把访问密钥告诉给他人。 😉windows被控端设置点击穿透下的软件下载按钮 进入页面后，官方推荐的是直接下载启动器，因此我们直接下载启动器即可。 下载完成后，点击安装即可。安装完后打开，软件大概长这样。 将刚才网页上的访问密钥填入，登录即可。 登陆完成后，点左边菜单栏的隧道，点击+号，进行相应的填写。例如这样 需要注意的是隧道类型和穿透节点的选择。隧道类型选择TCP（想使用ssh方式，也是选择TCP），穿透结点选择一个可以用的就行，本地IP填写127.0.0.1即可。填写完成后点击创建，隧道就创建成功了。 隧道的创建也可以直接在网页上创建，然后在启动器中刷新即可。 最后，点击开启刚才的隧道，会弹出日志信息，记住这个日志信息上面的IP或者服务器域名，待会通过这个IP连接被控电脑： 至此，内网穿透全部搞定，被控电脑全部设置完毕。 😉远程连接被控端上面创建内网穿透的过程其实就是分配了一个公网IP，所以接下来我们可以通过这个公网IP来访问我们的电脑； win10提供了相当给力的远程连接工具：“远程桌面连接”。可以在windows系统之间进行远程控制。 如果没有启动远程桌面连接，那么按照下述步骤设置。 打开我的电脑，右键点击属性 选择远程设置 点击允许远程协助连接此计算机即可开启。 开启之后，打开远程桌面连接程序，直接电脑的左下角菜单栏搜索即可出来。填入内网穿透的地址、远程计算机账户名、密码(无密码留空)即可远程。 😉ubuntu被控端设置ubuntu被控端需要下载frpc客户端，点击穿透下的软件下载按钮，进入后选择linux系统 至于选择哪一个架构，可以在ubutnu系统中在终端使用命令查看： 1dpkg --print-architecture 或者使用1uname -m 详情可参考博客查看Linux系统架构的命令。我的是amd64，因此选择amd64点击右边的复制链接。 在终端使用下面的命令进入 /usr/local/bin 目录并下载文件,确保现在已经处于有 root 权限的环境下。 12345678910cd /usr/local/bin# 一般来说只需要使用这条命令:wget -O frpc &lt;下载地址&gt;# 如果上面的命令报错，请尝试这条:curl -Lo frpc &lt;下载地址&gt;# Linux frpc 通常已经过 UPX 压缩，如需下载未压缩的版本请在下载地址尾部加上 _noupx 然后设置权限并校验文件是否有损坏： 123chmod 755 frpcls -ls frpcmd5sum frpc 此时 frpc 就安装完成并可以正常使用了。可以用此命令查看 frpc 版本号：1frpc -v 😉ubutnu 使用 frpc通过上节安装完成后，在终端使用命令开启frpc，注意加root权限：1sudo frpc在 Token 后面的文本框内输入访问密钥，然后使用 Tab 键切换到 Login 按钮并按 回车 键登录 (若终端支持也可使用鼠标进行操作)： 登录成功后 TUI 会显示当前账户下的隧道列表，使用方向键选中想要启动的隧道，按空格标为绿色 (或使用鼠标直接点击隧道)： 可以一次性启用多个隧道，但是这些隧道必须位于同一节点下,也可以直接选中节点来启用该节点下的所有隧道 选择完毕后，即可启动隧道，相关启动参数会被保存到配置文件 frpc.ini 中，下次不带参数直接运行 frpc 时不再显示 TUI 而是直接启动隧道。 至此，ubuntu的被控端部分设置完毕，远程只需要填入得到的公网ip或者域名即可。 例如，隧道启动成功后，使用vscode的远程remote插件连接ssh，那么只需要打开 然后输入对应的ip和端口 如：1ssh YHS@2.tcp.vip.cpolar.cn -p 14884 YHS为被控电脑的用户名，2.tcp.vip.cpolar.cn为公网ip，14884为远程端口号。这样就可以连接上ssh了。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://chh3213.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"hexo+gitee/github进行博客搭建","slug":"hexo-gitee-github进行博客搭建","date":"2022-06-20T05:56:11.000Z","updated":"2022-10-28T12:20:56.877Z","comments":true,"path":"2022/06/20/hexo-gitee-github进行博客搭建/","link":"","permalink":"https://chh3213.github.io/2022/06/20/hexo-gitee-github%E8%BF%9B%E8%A1%8C%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"使用hexo工具和gitee/github搭建自己的博客。","text":"使用hexo工具和gitee/github搭建自己的博客。 1. 使用gitee（github）与hexo好处 gitee 是国内的网站，相较于 github 访问速度更快； github是国外的网站，可以写一些比如科学上网之类的博客不至于发布不了。 gitee和github免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； hexo是大家使用非常广泛的静态博客； Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. 安装2.1 安装NodejsHexo 依赖 Node.js 和 NPM包管理，Node.js 安装后会自带NPM。因此，只需安装好node.js即可。 不管是macOS还是Windows系统，直接去nodejs官网下载安装包下载安装即可，属于傻瓜式安装（点击下一步、下一步。。。）这里不过多介绍。 2.2 安装git由于后面我们需要用git管理仓库，所以这边需要安装git。方法也很简单，直接去官网下载即可，也属于傻瓜式安装。 安装完成后，你的右键菜单栏会出现这两个标签： 可以打开CMD，进入命令行，运行git命令看是否安装成功： 1git --version 能够输出版本号则表示正常。 2.3 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 注：npm管理工具在安装好nodejs后就会自带，所以不需要额外安装。 打开cmd命令行或者右键选择git bash here，输入： 1npm install -g hexo-cli 即安装成功。 3. 建站hexo安装完成后，即可开始初始化hexo项目，进行建站。 进入到你打算存放博客源代码的目录下，执行初始化命令： 1234# 初始化文件夹名为 hexo_bloghexo init hexo_blogcd hexo_blognpm install hexo_blog为存放博客的文件夹名字，你可以按照自己需求取，例如我这里取得就是hexo_blog。 初始化完成后，hexo_blog文件夹下的文件目录大致如下： 12345678910.├── _config.yml # 网站的配置信息├── node_modules # 应用依赖信息├── package-lock.json├── package.json # 依赖包├── scaffolds # 模板文件├── source # 资源文件夹是存放用户资源的地方│ ├── _drafts # 草稿文件夹，刚初始化时可能不存在│ ├── _posts # 文章/帖子源码列表└── themes # 博客主题 其中_config.yml文件是配置文件，以后需要经常打交道的。里面的各个参数可以参考网站。source文件夹是存放用户资源的地方，即以后你写的博客都存放在这里。 4. 启动初始化项目后默认会安装相关的依赖，接着在命令行输入如下命令即可在本地运行查看博客 ： 123456# 启动服务，默认端口为 4000，启动服务后可以在浏览器输入 `http://localhost:4000` 查看效果hexo server# 简写方式hexo s# 还可以使用 -p, 指定 8888端口hexo s -p 8888 5. 配置建站完成后我们需要进行 配置，hexo 中主要有两项配置。 站点配置文件，路径为 /_config.yml ； 主题配置文件 ，路径是 /themes/(自己下载的主题)/_config.yml 。 站点配置文件主要是有以下几个基础选项 12345678910111213# Hexo Configuration# 网站主标题，SEO元素之一title: blog# 网站副标题，可选subtitle:# 网站描述, SEO元素之一，用于告诉搜索引擎关于这个站点的描述description: # 网站的关键词keywords: # 网站作者author: chh3213# 网站使用的语言, 由于 Hexo 具备多语言配置，默认为英文，若需要中文语言，则修改如下language: zh-CN 其余配置，可以具体参考hexo的文档。 5.1 主题配置熟悉了博客系统的操作后，接下来就是美化博客。Hexo 支持主题，我们可以根据官网的创建主题教程自己来设计，也可以直接在主题商城 中找现成的主题。 例如，笔者这边选择了hexo-theme-yilia 主题配置很简单，进入hexo-theme-yilia 的仓库，复制git clone的地址。 然后在hexo_blog文件夹目录下，git bash中输入： 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题在hexo_blog文件夹目录下的 themes 里面，如图：然后在 站点配置文件(/_config.yml) 中修改里面的 theme: landscape 为 theme: yilia 。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 最后启动主题即可。 123hexo clean # 启动主题前需要清除缓存与已部署的文件hexo generate # 生成静态网页hexo s # 本地查看博客 6. 部署到gitee pages我们使用git进行部署，可以将网站部署至私人服务器、也可以部署到免费的github pages或者gitee pages上。这边笔者选择的是gitee pages，因为github pages有时候不用点科学手段进不去。。。 6.1 创建一个gitee仓库 注意：这里需要注意的一点是，如果你想直接通过域名就可以访问到你的博客个人网站，创建仓库的时候仓库名要和用户名保持一致。例如，我的gitee用户名为caohuanhui，我创建的仓库名是caohuanhui，那我访问的时候直接使用https://caohuanhui.gitee.io/就可以直接访问了。但是，如果我创建的仓库名和用户名不一样，比如我创建仓库的时候，仓库名为blog，那我访问的时候，就必须要域名+仓库名才能访问，如https://caohuanhui.gitee.io/blog。 至于是否选择开源，这边建议选择私有，因为这个仓库，还可以用来进行博客源代码备份，后面会提到。 点击创建即可，成功创建一个gitee仓库。 6.2 配置路径 进入刚创建的仓库，点击 克隆/下载，复制 Https 地址 ==注==：这边并没有强制要求选择https方式，选择ssh方式也是可以的。 打开博客根目录，修改_config.yml 文件主要修改以下内容： 1234deploy: type: git repository: https://gitee.com/caohuanhui/caohuanhui.git # 刚才复制的 Https 地址 branch: pages # 部署到 pages 分支，如果该分支不存在，就会自动创建它 接下来我们还需要安装一个插件，在 git bash 下输入 1npm install hexo-deployer-git --save 如果我们没有安装这个插件，此时直接执行部署的命令 hexo g -d 的话一般会报如下错误： 1Deployer not found: gitee 或者 Deployer not found: git 6.3 开启GiteePages服务进入到刚才创建的gitee仓库，找到服务，点击Gitee Pages开启GiteePages服务 如果第一次开启Gitee Pages服务，会让你上传身份证进行验证，验证通过后即可使用。 进入到页面之后，选择GiteePages服务需要部署的分支，例如我这里要部署的分支为pages。推荐勾选上强制使用HTTPS，选择完毕之后点击启动（更新）便可开启GiteePages服务。 接着开始部署。如果你还没配置git账号的话，会提示你输入账号密码，输入正确的账号密码后就部署成功了。 1hexo g -d 每次部署成功后，都需要到GiteePages上点击更新。 6.4 github pages部署如果使用github pages，则步骤 类似。 在 GitHub 新建一个名称为 {username}.github.io的仓库，username是你的github用户名 打开根目录下的 _config.yml 文件，找到 Deployment ，修改如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/CHH3213/CHH3213.github.io.git branch: master 与giteePages 完全一致，只是地址不同，以及branch这里一定要是master分支。 启动GitHub Pages 在博客仓库的Settings界面，下拉找到GitHub Pages，生成博客网址部署成功后就可以通过https://{github用户名}.github.io/ 访问个人博客了 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而笔者所使用的是User Pages。简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 6.4. 博客源代码备份至于上述博客源代码的备份（即hexo_blog文件夹下的备份），笔者同样使用的是gitee仓库。 为了高效利用之前创建的部署gitee pages的仓库，所以这边并没有再额外创建一个仓库存放源代码，而是创建了两个分支，一个分支（hexo）用来存放源代码，一个分支（pages）用来存放博客部署后生成的文件，其中，存放博客源代码文件的分支设为主分支，如下图所示。 然后只需要通过一系列git操作，将本地源代码上传至仓库的hexo分支即可（这部分git基础操作就不在这介绍了）。 7. 写作一般我们都会使用 hexo new &lt;title&gt; 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 命令编译 时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是整个 Hexo 流程。 这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。 笔者个人的写作习惯是： 创建草稿 (drafts ) 在草稿上进行写作 整理细节并在本地服务器上查看效果(server) 发布至正式的帖子上 生成静态文件并部署 7.1 创建草稿12# hexo new draft &lt;title&gt;hexo new draft 博客名称 Hexo 提供 draft 机制，它将新文章将建立在 source/_drafts 目录下。生成的文件博客名称.md 是一个 markdown 文件，默认的草稿模板内容如下： 1234---title: 博客名称tags: --- 在/scaffolds目录下可以修改draft、page、post(草稿、主页面、发布的文章)的模板。 7.2 在本地服务器预览草稿1hexo s --draft Hexo 的 Hexo server 另外提供 --draft 参数，这让我们可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。 7.3 发布草稿如果我们在本地服务器上校对完草稿细节后，可以将草稿发布为文章，否则在后续生成博客静态文件时不会被打包出来： 12# hexo publish [layout] &lt;filename&gt;hexo publish post 博客名称 输入命令后你可以发现发布的文章被转移到了source/_posts/上，这样就完成了本地的文章发布。 7.4 生成静态文件并部署 Hexo框架的一项工作就是将源文件 markdown 最后生成为 HTML： 123456# 生成文件hexo g# 监控文件变化，并生成静态文件hexo g --watch# 生成文件并部署hexo g -d 以上便是完整的部署过程了！ 8. 常用hexo命令12345678hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清楚缓存 缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： 123hexo s -g #生成并本地预览hexo g -d #生成并部署hexo clean &amp; hexo generate &amp; hexo server #重新生成并本地预览 参考资料 https://hexo.io/zh-cn/docs/ https://su-lemon.gitee.io/post/5bd42e8c.html https://developer.aliyun.com/article/794909 Gitee+Hexo配置个人博客中的坑","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://chh3213.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://chh3213.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"博客主页美化","slug":"博客主页美化","date":"2022-06-12T05:17:24.136Z","updated":"2022-11-01T13:54:58.482Z","comments":true,"path":"2022/06/12/博客主页美化/","link":"","permalink":"https://chh3213.github.io/2022/06/12/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/","excerpt":"搭建的hexo博客的美化技巧。","text":"搭建的hexo博客的美化技巧。 除了主题自带的技巧外，这边再总结一些我用到的技巧。 文章封面生成随机图片使用: 只要请求图片时, 将路径改为API提供的路径即可. 对于Markdown来说: 1![image_infp](API_URL) 对于HTML来说是修改src属性: 1&lt;img src=&quot;API_URL&quot; /&gt; 但是仅仅这样做会出现一个问题: 当前页面使用同一个api链接的文章, 图片显示的都是同一张!(说好的随机呢?) 问题就出现在, 发起请求时, 由于链接地址是同一个, 实际上即使同一个页面中有多个(相同)图片链接, 也仅仅发起一次请求, 所以也就返回一张图片了! 所以只要修改链接不同即可! 以本博客使用到的api为例: http://api.mtyqx.cn/tapi/random.php 可以在末尾添加?x, 其中x是一个数字, 如: http://api.mtyqx.cn/tapi/random.php?54615 此时这是两个完全不同的请求, 所以显示的图片即为不同了! 附随机图片的一些API 二次元: https://img.paulzzh.tech/touhou/random 二次元: http://www.dmoe.cc/random.php 二次元：http://api.mtyqx.cn/tapi/random.php 添加动漫人物(看板娘)Hexo博客本身支持看板娘的，三步即可。 第一步，在主目录下执行命令： 1npm install --save hexo-helper-live2d 第二步，同样在主目录下执行： 1npm install live2d-widget-model-shizuku live2d-widget-model-shizuku是可选项。可选的模型如下： 123456789101112131415161718192021live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-harulive2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 第三步，在根目录配置文件（_config.yml）中添加如下代码： 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 然后重新部署即可。 hexo博客本身看板娘角色比较单调，stevenjoezhang大佬写了一个可以说话，可以换装的看板娘项目并开源，使用起来也是非常的方便。下面是Nexmoe主题下的安装步骤。 下载大神的仓库live2d-widget到主目录\\themes\\nexmoe\\source下，修改live2d-widget目录下的autoload.js文件中的路径 123// 注意：live2d_path 参数应使用绝对路径//const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;;const live2d_path = &quot;/live2d-widget/&quot;; 往\\themes\\nexmoe\\layout\\_partial\\_post目录下的header.ejs添加以下代码(在第一个div标签内): 123// 注意：live2d_path 参数应使用绝对路径//const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;;const live2d_path = &quot;/live2d-widget/&quot;; 在根目录配置文件（_config.yml）中添加如下代码： 12live2d: ##自定义看板娘动画 enable: true 然后重新部署即可。想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 和 waifu.css。其实看板娘可以侧边隐藏，对样本的修改影响也不大。 添加评论本篇博客使用的主题是nexmoe主题，它的配置评论的方式如下（gitalk为例）： 在GitHub上申请OAuth application 点击生成后，记住Client ID和 Client Secret 在themes文件夹下的_config.nexmoe.yml文件中，把刚才的Client ID和 Client Secret填在下面方框： 12345678910111213141516slotComment: &#x27; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;const gitalk = new Gitalk(&#123; clientID: &quot;&quot;, clientSecret: &quot;&quot;, repo: &quot;CHH3213.github.io&quot;, owner: &quot;CHH3213&quot;, admin: &quot;CHH3213&quot;, id: decodeURI(window.location.pathname) &#125;);gitalk.render(&quot;gitalk-container&quot;)&lt;/script&gt;&#x27; 即下图所示：文章代码中出现过这两个链接 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt; 这两个链接指引的文件是配置gitalk的代码，可以下载后保存于自己的网站并修改文章中的链接，获得相同的效果。 然后配置完成后，在需要开启评论框的文章中，开启评论：comments: true即可。 最后，hexo g -d部署生成后登录评论框初始化即可。 nexmoe主题的评论已经支持了任何评论系统，在themes/nexmoe/layout/post.ejs文件中可以看到，它是这么开启的 添加页面点击出现爱心特效 在 themes/你选择的主题/source/js 下新建文件 heart.js文件 ，添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586!(function (e, t, a) &#123; function n() &#123; c( &quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot; ), o(), r(); &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, (d[e].scale += 0.004), (d[e].alpha -= 0.013), (d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;)); requestAnimationFrame(r); &#125; function o() &#123; var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e); &#125;; &#125; function i(e) &#123; var a = t.createElement(&quot;div&quot;); (a.className = &quot;heart&quot;), d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s(), &#125;), t.body.appendChild(a); &#125; function c(e) &#123; var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try &#123; a.appendChild(t.createTextNode(e)); &#125; catch (t) &#123; a.styleSheet.cssText = e; &#125; t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a); &#125; function s() &#123; return ( &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; ); &#125; var d = []; (e.requestAnimationFrame = (function () &#123; return ( e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60); &#125; ); &#125;)()), n();&#125;)(window, document); 在themes/你选择的主题/layout/layout.ejs文件的body标签内添加： 12&lt;!-- 页面点击小红心-- 20221025--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/heart.js&quot;&gt;&lt;/script&gt; 重新部署生成后，即可出现特效。 1hexo clean &amp; hexo generate &amp; hexo server 浏览器网页标题特效 当用户访问你的博客时点击到了其他网页，我们可以让网页标题产生特效，呼唤用户回来，首先在目录 themes/你选择的主题/source/js 下新建一个 funnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617&lt;!--浏览器搞笑标题--&gt;var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヽ(●-`Д´-)ノ我在这等你！&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヾ(Ő∀Ő3)ノ谢谢你回来！&#x27; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 在themes/你选择的主题/layout/layout.ejs文件的body标签内添加： 12&lt;!--搞笑title--&gt;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/funnyTitle.js&quot;&gt;&lt;/script&gt; 重新部署即可。 添加代码块复制功能博客主题本身并没有集成代码块复制功能，因此这里给主题添加这个功能。 此方法对所有没有代码块复制功能的主题都有效，基于 https://github.com/zenorocha/clipboard.js 实现. 参考博客。 下载js文件保存到themes/你的主题/source/js目录下，重命名为clipboard-min.js。 在themes/你的主题/source/js目录下，创建clipboard-use.js，文件，添加内容如下： 123456789101112131415161718192021222324252627282930313233$(&quot;.highlight&quot;).wrap(&quot;&lt;div class=&#x27;code-wrapper&#x27; style=&#x27;position:relative&#x27;&gt;&lt;/div&gt;&quot;);/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function () &#123; var copyHtml = &#x27;&#x27;; copyHtml += &#x27;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&#x27;; copyHtml += &#x27; &lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&#x27;; copyHtml += &#x27;&lt;/button&gt;&#x27;; $(&quot;.highlight .code&quot;).before(copyHtml); var clipboard = new ClipboardJS(&#x27;.btn-copy&#x27;, &#123; target: function (trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on(&#x27;success&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制成功&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); clipboard.on(&#x27;error&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制失败&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); &#125; initCopyCode();&#125;(window, document); 因为css的”子绝父相”在父元素有滚动条的情况下子元素会跟随父元素滚动，所以使用 hexo添加复制代码块的功能的代码会有代码块横向超出时出现“bug”的情况，解决方案是使用js动态给代码块元素添加父元素(相对定位)作为复制按钮子元素的定位参照父元素，而代码块元素则起到滚动元素的作用。即上文代码中的第一行代码。 clipboard提供了复制成功/失败(success/error)后的自定义事件触发，故可以通过这两个方法修改按钮文字，再通过setTimeout()方法在复制1s后再次显示“复制” 在themes/你的主题/source/css/style.css或者themes/你的主题/source/css/style.styl 样式（有的主题是css格式，有的是styl格式，差别并不大。）中添加如下代码： 1234567891011121314151617181920212223242526272829303132333435//代码块复制按钮.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px&#125;.code-wrapper:hover .btn-copy &#123; opacity: 1; z-index: 100;&#125; 引用js文件，将以下代码加入到你的layout布局文件（例如，nexmoe主题是在themes/你的主题/layout/layout.ejs文件）的body标签内： 123&lt;!-- 代码块复制功能,注意src路径 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/clipboard-min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/clipboard-use.js&quot;&gt;&lt;/script&gt; 当然将 clipboard-min.js 和 clipboard-use.js 保存到CDN上，通过远程引用也可以. 最后重新部署即可。 代码块高亮在nexmoe主题中，使用hexo原生的hightlight并没有起作用，根据官网教程，这里给出两种方法进行代码块的高亮。 使用prismjs进行代码高亮Prism是一种轻量级的，可扩展的语法突出显示工具，在构建时考虑了现代Web标准。 进入prismjs官网，依据情况选择主题、语言和最下方的插件。 其中语言我全部勾选了，插件如图所示选择了两个。选择完成后点击下方的下载按钮，分别下载css和js文件。下载后的文件可以保存在themes/你的主题/source/js文件夹下。 下载完成后，引入css文件和js文件即可。打开themes/你的主题/layout/layout.ejs文件（部分主题可能是swig格式），在head标签内添加css文件链接： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/prism.css&quot;&gt; 其中href后面填写的就是你下载的css文件的路径。假如你放在了themes/你的主题/source/js文件夹下，那么引入方式为： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/js/prism.css&quot;&gt; 即下图： js文件的引入类似，也是在这个文件中，但是此时是在body标签内引入。 1&lt;script src=&quot;/js/prism.js&quot; async&gt;&lt;/script&gt; 即下图： 同理，src是你的路径。 在完成上述步骤后，在博客的配置文件_config.yml中配置： 12345678highlight: enable: falseprismjs: enable: true preprocess: true line_number: true line_threshold: 0 tab_replace: &#x27;&#x27; 最后重新编译即可。 使用hightlight.js进行代码高亮使用hightlight.js配置的方式与prismjs类似。 首先前往hightlight.js下载页面，勾选常用语言后，下拉点击Download按钮 将下载后的文件解压在themes/你的主题/source/js文件夹下。 打开themes/你的主题/layout/layout.ejs文件，在body标签内引入： 1&lt;script src=&quot;/js/highlight/highlight.min.js&quot;&gt;&lt;/script&gt; 即下图： 注意src是你存放的路径。 然后，打开hightlight/styles/文件夹，里面有很多css主题样式，选择一个你想要的主题，例如，我选择的是atom-one-dark.min.css样式，那么就在layout.ejs文件下的head标签内引入： 1&lt;link href=&quot;/js/highlight/styles/atom-one-dark.min.css&quot; rel=&quot;stylesheet&quot;&gt; 即下图： 最后，在博客配置文件_config.yml中配置： 1234567highlight: enable: true line_number: true auto_detect: true tab_replace: &#x27;&#x27; wrap: true hljs: true 编译部署后即可生效。 Sakana石蒜模拟器偶然在网上发现了这个非常可爱有趣的小动态玩偶，现在把它集成到网站上去，简易集成可参考博客。 打开themes/你的主题/layout/layout.ejs文件，在body标签内引入： 12345678910111213141516171819&lt;!--sakana模拟器--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;&lt;style&gt; html &#123; background: #CCC; &#125; html .sakana-box &#123; position: fixed; right: 0; bottom: 0; transform-origin: 100% 100%; /* 从右下开始变换 */ &#125;&lt;/style&gt;&lt;div class=&quot;sakana-box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sakana@1.0.8&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/sakana.js&quot;&gt;&lt;/script&gt; 在themes/你的主题/source/js文件夹下新建sakana.js文件，填写内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//设置sakana状态// 设定静音Sakana.setMute(true);// 获取静音状态const &#123; isMute &#125; = Sakana.Voices;// 启动const sakana = Sakana.init(&#123; // 选项: 默认值 el: &#x27;.sakana-box&#x27;, // 启动元素 node 或 选择器 character: &#x27;chisato&#x27;, // 启动角色 &#x27;chisato&#x27;,&#x27;takina&#x27; inertia: 0.1, // 惯性 decay: 0.99, // 衰减 r: 60, // 启动角度 y: 10, // 启动高度 scale: 0.5, // 缩放倍数 translateY: 0, // 位移高度 canSwitchCharacter: false, // 允许换角色 onSwitchCharacter(character)&#123; // 切换角色回调 console.log(`$&#123;character&#125; dayo~`); &#125;,&#125;);// 设定归零角度sakana.setOriginRotate(10);// 获取角色运行状态const v = sakana.getValue();// 确保运行sakana.confirmRunning();// 切换角色sakana.switchCharacter();// 暂停动作sakana.pause();// 恢复动作sakana.play();// 切换特定角色sakana.setCharacter(&#x27;chisato&#x27;); 博客重新部署生成即可。 使用不蒜子添加访问量和阅读量功能添加访问量等信息以nexmoe主题为例，打开themes/nexmoe/layout/_partial/header.ejs文件，在&lt;div class=&quot;nexmoe-copyright&quot;&gt;标签内添加以下代码即可： 12345678&lt;!-- 添加访问数 --&gt; &lt;div style=&quot;font-size: 13px&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://widget.heweather.net/standard/static/css/he-standard.css?v=1.4.0&quot;&gt; &lt;script src=&quot;https://widget.heweather.net/standard/static/js/he-standard.js?v=1.4.0&quot;&gt;&lt;/script&gt; &lt;script async=&quot;&quot; src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 本站总访问量 &lt;a id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/a&gt; 次&lt;br&gt; 本站访客数&lt;a id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/a&gt;人次 &lt;/div&gt; 添加每篇文章阅读量信息以nexmoe主题为例，打开themes/nexmoe/layout/_partial/_post/word-count.ejs文件，添加以下代码即可： 123&lt;a&gt;&lt;i class=&quot;nexmoefont icon-areachart&quot;&gt;&lt;/i&gt; &lt;span class=&quot;archive-article-date&quot;&gt;阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 添加位置如下：","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://chh3213.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"主页美化","slug":"主页美化","permalink":"https://chh3213.github.io/categories/%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://chh3213.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"美化","slug":"美化","permalink":"https://chh3213.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"ubuntu20.04配置Qv2ray","slug":"ubuntu20-04配置Qv2ray","date":"2022-04-15T14:48:35.000Z","updated":"2022-10-27T05:38:26.432Z","comments":true,"path":"2022/04/15/ubuntu20-04配置Qv2ray/","link":"","permalink":"https://chh3213.github.io/2022/04/15/ubuntu20-04%E9%85%8D%E7%BD%AEQv2ray/","excerpt":"","text":"参考资料：Ubuntu20.04下成功配置Qv2ray 1. 安装客户端软件中心搜索qv2ray安装即可 2. 配置客户端2.1 软件配置打开Qv2ray, 会在主文件夹下的snap下自动生成一个名为qv2ray的文件夹 进入https://github.com/v2ray/v2ray-core/releases ，根据自己的系统下载相应的核心文件，我这边下载的是v2ray-linux-64.zip 而后在目录/home/your_user_name/snap/qv2ray/4576/.config/qv2ray文件夹下新建vcore文件夹，并将之前下载的核心文件解压缩后全部拷贝到vcore文件夹内。注意这里的4576版本号是不固定的，根据自己的来就好。另外就是需要按住ctrl+h才能显示隐藏的.config文件夹。 以上完成后验证核心文件。点击Qv2ray界面中的首选项： 然后点击内核设置—&gt;检查V2Ray核心设置： 如果一切正常，则会出现检查通过提示： 然后便可以点击OK，关闭。除此之外，还需配置网络代理，首先查看入站设置中的默认网络代理： 例如我这里默认的是socks端口为7891,http端口为7890.这个端口号是可以修改的，这里用默认的就行。随后，ubuntu桌面右上角打开ubuntu的系统设置，选择网络—&gt;网络代理 将网络代理切换为手动，如图所示，将HTTP和HTTPS代理端口填写为上面获取到的HTTP端口，Socks主机端口号也填写成上面获取到的端口号即可。 这一部分配置完成。 注：默认端口号是可以更改的，只需要让软件中的端口号和ubuntu系统设置中的网络代理端口号保持一致，即可。 2.2 node配置回到软件首页配置入网config文件。选择新建,出现如下信息： 我们需要将获取到的node复制粘贴到所述的分享链接框内即可。至于节点的获取，在这里分享一个github上的free获取地址：free node导入node后，就会出现类似如图所示的界面： 双击任何一个node，即可连接成功。如果不需要连接时，点击断开连接以及将ubuntu系统中的网络代理从手动切换为禁用。最后祝小伙伴们使用愉快。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"https://chh3213.github.io/tags/VPN/"}]},{"title":"windows下配置Qv2ray","slug":"windows下配置Qv2ray","date":"2022-04-15T14:45:54.000Z","updated":"2022-10-27T05:38:40.005Z","comments":true,"path":"2022/04/15/windows下配置Qv2ray/","link":"","permalink":"https://chh3213.github.io/2022/04/15/windows%E4%B8%8B%E9%85%8D%E7%BD%AEQv2ray/","excerpt":"","text":"参考资料Windows下成功配置Qv2ray 1. 软件下载点击https://github.com/Qv2ray/Qv2ray/releases，根据自己系统选择对应的下载，我这边选的是 2. 配置核心文件点击https://github.com/v2fly/v2ray-core/releases，根据你自己的环境选择对应的压缩包下载，成功后先从桌面打开qv2ray, 进入界面后在设置里根据提示的核心文件路径进行配置。 根据路径提示需要有一个名为vcore的文件夹，因此这里必须在相应路径下新建该文件夹。vcore文件夹新建好之后需要将刚才下载的压缩包里的核心文件拷贝过来。 接着通过核心验证。 3. node配置回到软件首页，选择导入,出现如下信息： 我们需要将获取到的node复制粘贴到所述的分享链接框内即可。至于节点的获取，在这里分享一个github上的free获取地址：free node导入node后，就会出现类似如图所示的界面： 双击默认分组，可以看到所有节点 双击任何一个node，即可连接成功。如果不需要连接时，点击断开连接即可。最后祝小伙伴们使用愉快。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"https://chh3213.github.io/tags/VPN/"}]}],"categories":[{"name":"主页美化","slug":"主页美化","permalink":"https://chh3213.github.io/categories/%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/"},{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"hexo博客","slug":"hexo博客","permalink":"https://chh3213.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"主页","slug":"主页","permalink":"https://chh3213.github.io/tags/%E4%B8%BB%E9%A1%B5/"},{"name":"Remote","slug":"Remote","permalink":"https://chh3213.github.io/tags/Remote/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://chh3213.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"博客","slug":"博客","permalink":"https://chh3213.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"美化","slug":"美化","permalink":"https://chh3213.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"VPN","slug":"VPN","permalink":"https://chh3213.github.io/tags/VPN/"}]}