{"meta":{"title":"一半是火一半是光的博客","subtitle":"","description":"给自己的知识一片栖息之地","author":"chh3213","url":"https://chh3213.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-06-11T13:15:27.244Z","updated":"2022-06-11T13:15:27.244Z","comments":true,"path":"archive.html","permalink":"https://chh3213.github.io/archive.html","excerpt":"","text":""},{"title":"关于CHH","date":"2023-12-28T03:29:26.399Z","updated":"2023-12-28T03:29:26.399Z","comments":true,"path":"about.html","permalink":"https://chh3213.github.io/about.html","excerpt":"","text":"👋 Hi, I’m @CHH3213 👀 I’m interested in Reinforcement Learning and Self-Driving 🌱 I’m currently learning RL, Python, C++, Control Theory… 📫 Reach me through chh3213@foxmail.com 但行好事，莫问前程! 自己并非是什么独一无二的人，只是一个普通人，要牢记三点： 要保持健康的状态； 不断提升自己的专业能力； 谨慎投资，不要想着能够暴富！ 时刻关注自己的成长和进步。 做事不能盲目追求速度，急功近利。单纯追求速度，不讲效果，反而达不到目的；只顾眼前小利，不讲长远利益，那就什么大事也做不成。厚积方可薄发，成功的基础在于积累，与其追求速成，不如先把底子练好，稳扎稳打才是最快的途径。"},{"title":"路漫漫其修远兮","date":"2023-03-02T06:09:09.612Z","updated":"2023-03-02T06:09:09.612Z","comments":true,"path":"study/index.html","permalink":"https://chh3213.github.io/study/index.html","excerpt":"","text":"欢迎访问我的CSDN博客主页。 学习项目我的github主页上以chh开头的仓库均为学习项目. 学习项目 项目名称 说明 chhCpp 学习C++仓库 chhRobotics 学习自动驾驶、控制理论相关仓库(python实现) chhRobotics_CPP 学习自动驾驶、控制理论相关仓库(c++实现) chhML 、chh-MachineLearning 学习机器学习仓库 chhRL 学习强化学习仓库 chhTricks 存放一些有意思的tricks 书籍资料学习过程中收集到的书籍资料。 总的路线图 编程编程部分主要聚焦于C++、python、数据结构与算法。 python的入门较为简单，因此可以采取即用即学的策略学。 c++语法学习可以跟着黑马程序员的视频学，讲得蛮清楚的，就是不够深入，深入还是得自己看书才行。 学习完基础语法后，便可以借助力扣或者牛客网刷题了，这里建议跟着labuladong或者代码随想录来进行针对性地刷题。这两者刷完后，再借助力扣随机刷题或者按照顺序刷题。 数据结构与算法的学习个人觉得跟着代码随想录或者labuladong的刷题就行，边刷边学，对于不理解的可以再上网查资料。 另外，书籍的选择上，c++系列的学习建议以下面的顺序由浅入深来学习： C++基础阶段:《C++ Primer Plus》第六版 C++进阶巩固:《C++ Primer 》第五版 C++精通阶段:《Effective C++》、《More Effective C++》以及《Effective Modern C++》。 C++应用阶段：就在github上找项目练手吧。 另外，这篇文章也给出了更详细的C++学习路线，可根据自身情况酌情选择。 对于C++的学习，一般做项目后都绕不开CMake的使用，CMake的教程可以参考这位博主的文章以及这个资料。 机器学习机器学习模块首先需要掌握机器学习和深度学习的基础知识，会搭建网络；进一步地，就是根据自身来选择方向了，比如CV，RL等。我自己的话就是RL方向，需要掌握强化学习的基础知识和理论，会应用强化学习解决工程项目。 下面是我学习过程中总结的一些资料 自动驾驶 自动驾驶包括了感知、定位、决策规划、控制等几大块。我主要聚焦于决策规划和控制。下面是我学习过程中的一些总结。 额外的辅助技能（工具）vim、docker、git等的掌握。 git就不必说了，必须掌握的技能。 git的学习可以参考：https://github.com/pcottle/learnGitBranching git常见问题的解决方案可以访问我的GitHub project. docker的学习，许多项目都会用到docker，因此有时间需要学一学，中文教程参考：https://yeasy.gitbook.io/docker_practice/。 vim在熟练使用之后可以让你编程效率提高，事半功倍，但是前期的转换挺痛苦。 vim的学习可以参考：https://vimschool.netlify.app/basics/以及https://www.openvim.com/sandbox.html。 vim工具的使用不是必须的，有时间的话可以学学，技多不压身。 任何的工具的使用都是为了能够更加方便地做事！"},{"title":"思维导图","date":"2021-04-17T14:41:51.000Z","updated":"2022-06-12T06:21:08.119Z","comments":true,"path":"xmind/index.html","permalink":"https://chh3213.github.io/xmind/index.html","excerpt":"","text":"Mind Map html, body { margin: 0; padding: 0; width: 100%; height: 100%; } 'use strict'; (function () { $(function () { $('.position').click(function (event) { var el = $(event.target); $('.position').removeClass('selected'); el.addClass('selected'); position = el.attr('data-position'); }); }); }); var position = 2; // 关闭百毫秒数 var closeTime = 50; var notifyFunc = function () { Notification.create( // Title \"欢迎使用思维导图✒️\", // Text \"思维导图操作说明：JMind使用手册\", // Illustration \"https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/component/思维导图/images/avatar4.jpg\", // Effect 'fadeInRight', // Position 1, 2, 3, 4 1, closeTime ); }; notifyFunc();"}],"posts":[{"title":"使用cloudflare 创建无限的免费图床","slug":"创建无限的免费图床","date":"2025-11-16T14:59:05.000Z","updated":"2025-11-17T15:33:19.374Z","comments":true,"path":"2025/11/16/创建无限的免费图床/","link":"","permalink":"https://chh3213.github.io/2025/11/16/%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E7%9A%84%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"免费图床开源项目：【链接直达】 视频教程：视频教程 优点 无限图片储存数量，你可以上传不限数量的图片 无需购买服务器，托管于Cloudflare的网络上，当使用量不超过Cloudflare的免费额度时，完全免费 无需购买域名，可以使用Cloudflare Pages提供的*.pages.dev的免费二级域名，同时也支持绑定自定义域名 支持图片审查API，可根据需要开启，开启后不良图片将自动屏蔽，不再加载 支持后台图片管理，日志管理，查看访问前20的Referer、IP、img,可以对上传的图片进行在线预览，添加白名单，黑名单等操作 利用Cloudflare pages部署使用R2 存储桶方式构建图床 点击Use this template按钮创建一个新的代码库。 登录到Cloudflare控制台. 在帐户主页中，选择 pages： 选择你创建的项目存储库，在 Set up builds and deployments部分中，Framework preset(框架)选 Next.js即可。 点击 Save and Deploy部署 。 创建D1 数据库 执行sql命令创建表（在控制台输入框粘贴下面语句执行即可） 12345678910111213141516171819DROP TABLE IF EXISTS tgimglog;CREATE TABLE IF NOT EXISTS tgimglog (`id` integer PRIMARY KEY NOT NULL,`url` text,`referer` text,`ip` varchar(255),`time` DATE);DROP TABLE IF EXISTS imginfo;CREATE TABLE IF NOT EXISTS imginfo (`id` integer PRIMARY KEY NOT NULL,`url` text,`referer` text,`ip` varchar(255),`rating` text,`total` integer,`time` DATE); 创建R2存储桶：依次点击：创建R2 存储桶时，首次进入的页面可能是这样的：虽然R2 存储桶m每月有免费的额度，但需要进行申请，推荐用PayPal 账户进行申请，会方便许多。只要不超出使用额度，就不会进行扣费，个人使用完全够用。 返回Pages 页面绑定D1 数据库和R2 存储桶D1 数据库的变量名称必须是 IMG,数据库就选择你刚才创建的，点击保存。R2 存储桶的变量名称必须是 IMGRS,存储桶同理，选择你刚才创建的，点击保存。 设置兼容性标志 设置兼容性标志，前往后台依次点击 设置-&gt;兼容性标志 填写 nodejs_compat 前往后台点击 部署 找到最新的一次部署点 重试部署。 部署完毕后就可以通过这里的网址进行访问最终顺利的话，你可以成功打开以下页面，选择R2，便可进行上传： 使用Telegram Bot 方式构建图床如果不想使用R2存储桶的方式，也可以使用Telegram Bot 创建图床。 创建Telegram Bot在电报中@botfather： 输入 /newbot：输入Bot 名称和Bot 名称，例如：TelegraphImagebot，注意必须以 bot结尾。 创建好后获取Bot Token，可以找到Bot Token，例如：123468:AAxxxGKrn5 回到pages 页面，设置变量变量名称为 TG_BOT_TOKEN,然后将上面的bot token 作为值填写进去，保存即可。 获取ID 机器人：@VersaToolsBot 创建一个频道，私有，公有都行： 将上一步中自己创建的机器人添加为该频道管理员： 随后，在频道内随便输入一个消息 将该消息转发到刚才的ID机器人 VersaToolsBot中： 随后在ID 机器人聊天框中会返回以下消息，复制频道ID（例如：-1234567）： 返回cloudflare 的pages页面，跟刚才一样添加变量，此时变量名为：TG_CHAT_ID，值为刚才的频道ID，保存即可。 最终设置好后是这样的 设置好上述值后，再重新部署即可。部署完成后就可以使用TG channel作为图床了！ 该项目所有可以设置的变量包括：| 变量名称 | 值 | type || —————- | —————- | —————- ||PROXYALLIMG | 反向代理所有图片（默认为false）| boolean ||BASIC_USER | 后台管理页面登录用户名称| string ||BASIC_PASS | 后台管理页面登录用户密码| string ||ENABLE_AUTH_API | 是否开启访客验证 （默认为false）| boolean ||REGULAR_USER | 普通用户 （访客验证）| string ||REGULAR_PASS | 普通用户密码| string ||ModerateContentApiKey | 审查图像内容的API key| string ||RATINGAPI | 自建的鉴黄api | string ||CUSTOM_DOMAIN | https://your-custom-domain.com (自定义加速域名) | string ||TG_BOT_TOKEN | 123468:AAxxxGKrn5 (从 @BotFather) |string ||TG_CHAT_ID | -1234567 (频道的ID,TG Bot要是该频道或群组的管理员) |string | Enjoy it!","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://chh3213.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"GPT-SoVITS | 1分钟微调中文声音克隆教程","slug":"GPT-SoVITS-1分钟微调中文声音克隆教程","date":"2024-02-03T07:36:05.000Z","updated":"2024-02-03T09:01:03.705Z","comments":true,"path":"2024/02/03/GPT-SoVITS-1分钟微调中文声音克隆教程/","link":"","permalink":"https://chh3213.github.io/2024/02/03/GPT-SoVITS-1%E5%88%86%E9%92%9F%E5%BE%AE%E8%B0%83%E4%B8%AD%E6%96%87%E5%A3%B0%E9%9F%B3%E5%85%8B%E9%9A%86%E6%95%99%E7%A8%8B/","excerpt":"这篇文章带你了解如何使用这个最新且强大的声音克隆开源项目：GPT-SoVITS GPT-SoVITS: https://github.com/RVC-Boss/GPT-SoVITS Colab: https://colab.research.google.com/github/RVC-Boss/GPT-SoVITS/blob/main/colab_webui.ipynb","text":"这篇文章带你了解如何使用这个最新且强大的声音克隆开源项目：GPT-SoVITS GPT-SoVITS: https://github.com/RVC-Boss/GPT-SoVITS Colab: https://colab.research.google.com/github/RVC-Boss/GPT-SoVITS/blob/main/colab_webui.ipynb 前言今天测试了下一个开源的声音克隆开源项目：GPT-SoVITS，深感强大。特此记录一下。 GPT-SoVITS: https://github.com/RVC-Boss/GPT-SoVITS Colab: https://colab.research.google.com/github/RVC-Boss/GPT-SoVITS/blob/main/colab_webui.ipynb 使用Colab的视频教程可参考youtube：https://www.youtube.com/watch?v=8JFUl2pFDAA&amp;t=3s 1. 使用Colab使用google Colab notbook 方式，可以不用占用自己本地资源，它的详细教程可以参考我贴的视频：https://www.youtube.com/watch?v=8JFUl2pFDAA&amp;t=3s 2. 使用windows 本地训练进入作者的github 仓库： https://github.com/RVC-Boss/GPT-SoVITS/tree/main 在readme中找到下面链接：prezip 把它下载下来，并解压。解压完成后进入目录，双击文件go-webui.bat。如果一切顺利的话会直接跳转到web界面 1. 前置数据准备1. UVR5人声伴奏分离&amp;去混响去延迟工具准备1分钟左右的人声数据音频文件，最好是纯人声，不要有bgm。如果有bgm的话，则需要进行人声伴奏分离，如下勾选按钮触发 加载成功后可以在终端中看到url。一般会直接跳转，如果没有跳转，则直接复制url到浏览器打开即可。 然后打开需要进行分离的音频==》选择模型，模型选择在web界面中有建议，这里我直接使用HP5模型==》接着选择输出格式，一般MP3即可。==》完成后点击转换===》最后转换完成即可在保存路径中看到，默认保存在output/uvr5_opt。 2. 语音切分注意，把刚才只有人声的音频文件路径复制到下面方框内，其他参数保持默认，点击开启语音切割。 切割结束后可以在目录里的output/slicer_opt 里面找到。 3. 中文批量离线ASR工具把刚才output/slicer_opt的完整路径复制到下面方框，点击开启离线批量ASR，等待任务完成即可。 任务完成后，可以在GPT-SoVITS-beta\\output\\asr_opt下面找到 4. 语音文本校对标注工具对上面处理好的asr list，可以打开语音文本校对标注工具进行校准。输入刚才生成的list文件路径，触发即可。 2. TTS 微调1. 训练集格式化 如上图，给微调的模型取个名字（不要中文），将之前处理好的数据list文件路径和切割后的音频目录分别填在2，3中。其他参数保持默认，最后点击开启一键三连. 如果第4步报错，则再点击一次重新运行看看。 2. 微调训练进入微调训练面板 依次点击开启soVITS训练和gpt训练即可。 成功之后可以在SoVITS_weights和\\GPT_weights目录里面找到训练好的模型。数字最大的哪个模型就是最终训练的模型，其他的都属于训练过程中保存的。 3. 推理 最后一步，就是使用训练好的模型进行推理了。 进入推理面板，首先刷新模型路径，刷新之后，可以找到刚才训练的模型，然后分别选择刚才训练好的gpt和sovits模型文件，点击开启TTS 推理webUI，稍等片刻，便可在终端中找到web ui url的地址。打开后是如下web ui界面 首先需要填入的就是第一步前置数据处理时切分的音频，随便选择一个填入，并将对应的文本填入。这里我处理的音频是中文，所以选择中文。 在下面输入自己想合成的文本，切分方式可以挨个尝试，看看什么方式效果更好。点击合成，稍等片刻后就可以查看合成的效果啦。个人认为合成后的效果还不错嘿嘿。 以上就是详细的使用步骤了。","categories":[{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/tags/AI/"}]},{"title":"linux系统配置clash-gui界面","slug":"linux系统配置clash-gui界面","date":"2023-11-12T06:46:19.000Z","updated":"2023-12-28T03:24:13.758Z","comments":true,"path":"2023/11/12/linux系统配置clash-gui界面/","link":"","permalink":"https://chh3213.github.io/2023/11/12/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AEclash-gui%E7%95%8C%E9%9D%A2/","excerpt":"Linux 系统下配置clash gui界面。","text":"Linux 系统下配置clash gui界面。 前言不久前原作者 的github仓库把clash for windows release删除了。目前我们还能使用的客户端有以下： 基于 clash.meta 内核的 Clash Verge（全平台 - 归档但不影响）：https://github.com/zzzgydi/clash-verge clashX.meta(macos):https://github.com/MetaCubeX/ClashX.Meta clash.meta for android（android - 归档但不影响）：https://github.com/MetaCubeX/ClashMetaForAndroid 其他 v2rayN (人在国外 - windows）：https://github.com/2dust/v2rayN sing-box（全平台）：https://github.com/SagerNet/sing-box/releases nekoray（windows，linux）：https://github.com/MatsuriDayo/nekoray shadowrocket，quanx，stash 等等付费或免费 ios 专用软件 v2rayNG/nekobox 等等 android 专用软件 clash for windows 备份虽然原作者的clash for windows 客户端已经删库跑路了，不过幸好有备份，这里是备份仓库：https://github.com/CHH3213/clash-for-windows-backup/releases/tag/v0.20.39 另外，附上原库的archive镜像的： https://web.archive.org/web/20231025075452/https://github.com/Fndroid/clash_for_windows_pkg/releases Linux配置clash for windows安装步骤 首先，下载Clash.for.Windows-0.20.39-x64-linux.tar.gz，下载完成后终端进入下载目录运行以下命令进行解压：&gt; 1tar zxvf Clash.for.Windows-0.20.39-x64-linux.tar.gz 解压完成后，可以将文件夹改名并移到/opt/：目录中（一般我们把安装的软件放在这里）： 1mv Clash\\ for\\ Windows-0.20.39-x64-linux /opt/clash-GUI 进入/opt/clash-GUI目录，可以使用ls查看目录内结构： cfw就是 clash for windows的意思，原作者把gui界面也移植到了linux中，我们可以运行以下命令打开：1./cfw 打开之后就是以下界面：可以将start with linux打开，这样就可以开机跟随系统启动了。 代理地址的导入只需要切换到Profiles页面，输入自己购买的订阅地址即可：订阅完成后，切换到Proxis页面就可以切换节点： 配置桌面图标clash for windowslinux版本默认是没有桌面图标的，如果退出了就只能重新通过命令行进入，比较麻烦，所以这里我们配置一下桌面图标。 进入~/.local/share/applications目录：1cd ~/.local/share/applications 创建clash_gui.desktop：1vim clash_gui.desktop 输入以下内容12345[Desktop Entry] Name=clash for linux Icon=/opt/clash-GUI/clash/clash.png Exec=/opt/clash-GUI/clash/cfw Type=Application 即如下： 需要根据自己的情况修改的只有以下两个字段： Icon 是桌面图标所在地址，可以自己网上找一个clash图标下载即可，例如我的图标是：https://github.com/CHH3213/clash-for-windows-backup/blob/main/clash.png。 Exec 表示cfw命令，这里我的cfw文件是在/opt/clash-GUI/clash/下，所以我的执行命令如上所是。然后保存退出。 最后增加权限:1chmod a+x clash_gui.desktop 然后便可在应用程序中看到clash的桌面图标了，下次我们直接点击桌面图标进入即可，右键图标还可以选择加入图标。 以上就是配置过程啦~~~ 开启系统代理不同于windows版本的clash-gui，linux下的系统代理需要自己在系统的网络中进行手动设置，设置过程如下： 打开ubuntu的系统设置，选择网络—&gt;网络代理 将网络代理切换为手动，如图所示，将HTTP和HTTPS代理端口填写为上面获取到的HTTP端口，Socks主机端口号也填写成如下形式。 这样系统代理部分就完成了，之后只要在clash中选择节点通常就可以使用了。如果需要关闭代理，那么同样把网络代理从手动改为关闭即可。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"clash","slug":"clash","permalink":"https://chh3213.github.io/tags/clash/"}]},{"title":"LRC转SRT字幕小工具","slug":"LRC转SRT字幕小工具","date":"2023-09-03T13:30:47.000Z","updated":"2023-09-03T13:36:29.061Z","comments":true,"path":"2023/09/03/LRC转SRT字幕小工具/","link":"","permalink":"https://chh3213.github.io/2023/09/03/LRC%E8%BD%ACSRT%E5%AD%97%E5%B9%95%E5%B0%8F%E5%B7%A5%E5%85%B7/","excerpt":"一个LRC歌词文件转SRT字幕文件的小工具。","text":"一个LRC歌词文件转SRT字幕文件的小工具。 LRC文件转SRT字幕文件最近比较空闲，没事在做MV视频，需要将LRC格式的歌词转为SRT字幕文件，以便于剪辑视频时导入。于是就写了这么一个小工具。 使用方法 前往GitHub下载源程序，进入目录后，通过运行 gui.py 文件打开 1python gui.py 运行后会弹出一个窗口 选择要转换的lrc文件，点击 convert 转换即可。 我也把它打包成exe文件了，所以可以下载.exe文件后运行即可。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://chh3213.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"stable-diffusion安装全流程+安装问题解决","slug":"stable-diffusion安装全流程-安装问题解决","date":"2023-07-08T11:43:45.000Z","updated":"2023-07-22T07:48:30.393Z","comments":true,"path":"2023/07/08/stable-diffusion安装全流程-安装问题解决/","link":"","permalink":"https://chh3213.github.io/2023/07/08/stable-diffusion%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"最近闲来无事，打算捣鼓一下stable-diffusion，来试试stable-diffusion的AI绘画能力。","text":"最近闲来无事，打算捣鼓一下stable-diffusion，来试试stable-diffusion的AI绘画能力。 安装流程使用stable-diffusion一般需要电脑有gpu，如果没有gpu，那么不推荐下载安装了。 首先，确保电脑里有git环境，否则，请下载安装git . 下载python3.10.6，如果怕污染原python环境，可以使用anaconda创建一个虚拟环境： 1conda create -n stable python=3.10.6 --y 使用git拉取stable-diffusion仓库 1git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 以上都准备好后，打开刚下载的stable-diffusion-webui目录中的 webui-user.bat脚本，将python3.10.6的路径写进去（例如，这里我的python路径是”D:\\ProgramData\\Anaconda3\\envs\\stable\\python.exe”），以及填写COMMANDLINE_ARGS参数： 12345678@echo offset PYTHON=\"D:\\ProgramData\\Anaconda3\\envs\\stable\\python.exe\"set GIT=set VENV_DIR=set COMMANDLINE_ARGS=--xformers --opt-sdp-no-mem-attention --listen --enable-insecure-extension-accesscall webui.bat 在终端运行 webui-user.bat（可直接双击打开），如果不报错的话会自动下载安装相应的依赖库注意： 在执行webui-user.bat后，会自动在你的 \\stable-diffusion-webui目录中创建一个 venv虚拟环境，所以后面执行的python环境实际上就是这个虚拟环境中的，所以我们可以把 webui-user.bat文件中的python路径更改为venv中的python路径，例如，我的如下： 1set PYTHON=\"E:\\CHH3213_KING\\NO_Chinese\\stable-diffusion-webui\\venv\\Scripts\\python.exe\" 安装成功后，会输出如下信息： 在浏览器中输入：127.0.0.1:7860便可以打开stable-diffusion-webui界面 安装过程中可能遇到的问题以上步骤是非常理想情况下输出的结果，但是，在执行 webui-user.bat后，大概率会碰到以下几个错误，我们一一来解决。 前言执行 webui-user.bat时，会碰到因为网络问题无法更新相应的依赖库的问题，请打开文件 \\stable-diffusion-webui\\modules\\launch_utils.py，将里面所有的 https://github.com替换成 https://ghproxy.com/https://github.com，改后如下所示： 错误1 1setuptools.installer is deprecated. requirements should be satisfied by a pep 517 installer 执行以下命令： 1pip install --upgrade setuptools 错误2 1\"RuntimeError: Couldn't install gfpgan.\" When installing webui 那么在终端执行以下命令： 1pip install git+https://ghproxy.com/https://github.com/TencentARC/GFPGAN.git@8d2447a2d918f8eba5a4a01463fd48e45126a379 --prefer-binary --default-timeout=100 --use-pep517 参考：https://github.com/CompVis/stable-diffusion/issues/506 错误3 1No module 'xformers'. Proceeding without it. 遇到这个错误，则在终端运行以下命令进行安装： 1pip install --force-reinstall --no-deps --pre xformers 参考：https://github.com/AUTOMATIC1111/stable-diffusion-webui/discussions/5303 错误4也是最难处理的一个错误： 1ModuleNotFoundError: No module named 'basicsr.version' 在参考https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/1598 后依旧解决不了，后来转换思路，直接下载对应的github仓库。首先，进入 stable-diffusion目录：\\stable-diffusion-webui\\repositories\\CodeFormer，在这个目录下，如果已经存在BasicSR文件夹，那么把它删除，再执行 1git clone https://github.com/XPixelGroup/BasicSR.git 在git clone完之后，再进入BasicSR目录，运行： 1python setup.py install 这样就把BasicSR安装完成了。 处理完以上报的错误后，再次执行 webui-user.bat脚本，就可以了。 错误5成功进入 127.0.0.1:7860 后，切换模型会显示 error，这个错误只需要在运行 webui-user.bat脚本前，在 webui-user.bat脚本中增加command 参数，例如，我的完整参数如下： 12set COMMANDLINE_ARGS=--xformers --opt-sdp-no-mem-attention --listen --enable-insecure-extension-access --medvram --autolaunch --deepdanbooru --no-gradio-queue 加载完成后即可。","categories":[{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/tags/AI/"}]},{"title":"ChatGPT openAI注册教程","slug":"ChatGPT-openAI注册教程","date":"2023-02-23T04:04:38.000Z","updated":"2023-11-12T09:10:16.445Z","comments":true,"path":"2023/02/23/ChatGPT-openAI注册教程/","link":"","permalink":"https://chh3213.github.io/2023/02/23/ChatGPT-openAI%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/","excerpt":"ChatGPT是基于深度学习的自然语言处理模型，具体来说，它是一个预训练的神经网络模型，使用了Transformer架构和自回归语言建模技术。","text":"ChatGPT是基于深度学习的自然语言处理模型，具体来说，它是一个预训练的神经网络模型，使用了Transformer架构和自回归语言建模技术。 参考资料中国用户怎么注册ChatGPT 1. chatgpt简介下面这段来自chatgpt的回答： ChatGPT是基于深度学习的自然语言处理模型，具体来说，它是一个预训练的神经网络模型，使用了Transformer架构和自回归语言建模技术。 训练ChatGPT的过程分为两个主要阶段： 预训练阶段：使用大规模的文本语料库对模型进行预训练，以学习自然语言的语法、语义和上下文等知识。在这个阶段，模型会通过自回归语言建模技术来预测下一个词语或子词，同时使用自注意力机制和残差连接来处理长序列和提高模型的效率。预训练过程可以分为两种方式：无监督学习和有监督学习。 微调阶段：将预训练好的模型进行微调，以适应特定的任务和应用场景。在这个阶段，模型会被输入一些带标签的数据，进行调整和优化，以在特定任务上取得更好的效果。 ChatGPT的优点是可以在多个自然语言处理任务上进行迁移学习，因为它已经学习了语言的通用表示。例如，它可以用于生成对话、文本分类、问答系统等多个任务。同时，它也可以通过不断的微调和优化来提高模型的效果和性能。 2. 注册步骤ChatGPT是一个由OpenAI开发的人工智能模型，由于OpenAI的API服务目前并不支持国内的用户，因此在国内使用ChatGPT需要多一些步骤。 准备一个海外ip 换句话说，就是需要使用梯子，使用梯子后就可以使用该网址查询到自己的IP地址属地，例如我用梯子后显示IP属地是美国。 打开chatgpt注册网址：https://chat.openai.com/auth/login，正常打开后显示以下界面，左边是登录(log in)，右边是注册(sign up)。 如果你有谷歌账号的话可以直接选择登录，使用谷歌邮箱登录，否则的话就按照正常步骤使用邮箱（国内国外邮箱都行）注册一个账号就行。 注册完成后选择登录，第一次需要填写你的姓和名(last name, first name)，填写完后就会到最关键的一步，使用手机号验证账号。 使用海外手机号接收短信 由于国内手机号不支持，所以需要使用海外的手机号接收验证码，这里我选择的是美国的手机号（注意，选择的手机号最好与你的ip所在地保持一致，这样接收到验证码的概率比较大）。 进入网址：https://sms-activate.org/cn，注册登录，点击左边的openai服务。 点击后会显示如下界面，其中的价格单位是卢布（1美元~=75卢布），选择一个跟你ip一致的国家，例如我选择的是美国，点击旁边的购物车，会显示你账户没有充足基金，所以我们花几块钱充值一下即可。 点击右上角的余额—&gt;充值 选择支付宝，充值1美元即可。 充值完成后，重新点击购物车，就会给我们分配一个号码 我们将号码填入chatgpt的手机号输入界面，发送验证码即可。 顺利的话我们就可以在刚才的接码平台上接收到验证码，填入后就顺利完成了注册。但有可能接码平台一直收不到验证码，这是我们可以多刷新几次，并且在20分钟内取消，重新申请一个号码是不计费的。 注册成功后就可以愉快地跟chatgpt聊天了。 对文字步骤不清楚的，可以观看YouTube视频，最后，祝使用愉快！ 后记国内其实也有一些chatgpt的接口，但并没有这个这么智能，感兴趣的进入下面这些网址看看。 https://you.com/ bilibili视频","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/categories/AI/"}],"tags":[{"name":"chatgpt","slug":"chatgpt","permalink":"https://chh3213.github.io/tags/chatgpt/"}]},{"title":"Ubuntu 修改鼠标光标主题并全局生效的方法","slug":"Ubuntu-修改鼠标光标主题并全局生效的方法","date":"2022-12-03T12:03:13.000Z","updated":"2022-12-03T12:26:26.576Z","comments":true,"path":"2022/12/03/Ubuntu-修改鼠标光标主题并全局生效的方法/","link":"","permalink":"https://chh3213.github.io/2022/12/03/Ubuntu-%E4%BF%AE%E6%94%B9%E9%BC%A0%E6%A0%87%E5%85%89%E6%A0%87%E4%B8%BB%E9%A2%98%E5%B9%B6%E5%85%A8%E5%B1%80%E7%94%9F%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"一般情况下，ubuntu默认的鼠标光标主题都比较不好看，所以我们可以通过以下方法进行修改。","text":"一般情况下，ubuntu默认的鼠标光标主题都比较不好看，所以我们可以通过以下方法进行修改。 获取鼠标光标主题在网站选择你想要的鼠标主题，例如我选择的是这一款。 点击下载后，将压缩包解压，并进入该文件夹内，将文件夹移至/usr/share/icons目录内 1sudo mv oreo_spark_pink_cursors /usr/share/icons 配置主题打开ubuntu系统左下角的查找应用程序，输入tweak，打开出现的应用（中文系统下是优化，英文系统是tweak）。在优化中选择外观，找到光标，选择你想安装的鼠标主题即可。 将下载的鼠标光标主题加入到 alternative x-cursor-theme在进行步骤2后，虽然鼠标主题生效了，但是并没有全局生效，在一些应用内依旧是原来的主题。所以，还需要进行以下步骤的配置。 打开终端，在终端输入以下命令，将鼠标光标主题加入到 alternative x-cursor-theme 中 1sudo update-alternatives --install /usr/share/icons/default/index.theme x-cursor-theme /usr/share/icons/你的鼠标光标主题名称/cursor.theme 20 例如，我的是 1sudo update-alternatives --install /usr/share/icons/default/index.theme x-cursor-theme /usr/share/icons/oreo_spark_pink_cursors/cursor.theme 20 接着，在终端输入以下命令： 1sudo update-alternatives --config x-cursor-theme 选择你的候选项编号 选择完成后，重启系统生效。 参考资料 https://vincentbel.com/ubuntu-change-cursor-theme/ https://www.youtube.com/watch?v=U_aQv74bHRQ","categories":[{"name":"页面美化","slug":"页面美化","permalink":"https://chh3213.github.io/categories/%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://chh3213.github.io/categories/Ubuntu/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://chh3213.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"Github主页美化","slug":"Github主页美化","date":"2022-10-27T02:02:00.267Z","updated":"2022-12-03T12:26:47.643Z","comments":true,"path":"2022/10/27/Github主页美化/","link":"","permalink":"https://chh3213.github.io/2022/10/27/Github%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/","excerpt":"Github主页的展示效果总结。","text":"Github主页的展示效果总结。 添加Github状态实现效果如下： 配置地址见：https://github.com/anuraghazra/github-readme-stats 添加Github小图标如何添加下图所示的小图标呢？ 方法很简单： 找到这个网站主页：https://shields.io/，这其实就是一个设计图标的网站。 打开官网主页后，找到下述图中信息，直接填充好文字和信息，以及图标的颜色，点击Make Badge，就会生成这个图标的地址。 ​ 然后在Github主页插入即可。插入方式如下： 1[![](https://img.shields.io/badge/CHH3213-CSDN-red)](https://blog.csdn.net/weixin_42301220?spm=1010.2135.3001.5343) 前面的是图标地址，后面的是链接地址。 生成后的图标如下： 使用Wakatime记录你的Coding数据WakaTime 是一款可以记录你的编码时间的工具，目前支持绝大部分主流的 IDE 以及 Chrome 浏览器。 安装Wakatime 注册 WakaTime 账号； 在官网找到对应的 IDE 插件，按照步骤安装 WakaTime 插件； 在个人设置页面复制 Secret API Key ，填入对应的 WakaTime 插件中； 过一段时间后，你就可以在 WakaTime 网站上看到你的编码情况； 主页接入waka-boxwaka-box提供了你每周的代码状态，并且更新为类似于下面的内容： 下面是接入步骤： 获取 GitHub API 令牌， 打开 Settings / Developer settings / Personal access tokens 页面，创建 Github Token ，权限部分勾选repo、workflow和user。生成后将token保存下来 进入 WakaTime 配置页面，勾选 Display coding activity publicly 与 Display languages, editors, operating systems publicly 查看 WakaTime 账号 api-key，并保存好 项目设置 在你的Github 自定义首页的仓库，打开 Settings / Secrets / Actions 页面，点击 New repository secret 添加 Secret API Key 密钥，Name 为 WAKATIME_API_KEY ，value 为Secret API Key 密钥 添加 Secret API Key 密钥，Name 为 GH_TOKEN ，value 为GitHub API token 配置Github Action工作流 打开该仓库的 Actions 页面，点击 set up a workflow yourself 设置工作流 文件名随意，清空初始内容，添入如下配置 1234567891011121314151617181920212223242526name: Waka Readmeon:schedule: # Runs at 12am IST - cron: &#x27;30 18 ** *&#x27;workflow_dispatch:jobs:update-readme: name: Update Readme with Metrics runs-on: ubuntu-latest steps: - uses: anmol098/waka-readme-stats@master with: WAKATIME_API_KEY: $&#123;&#123; secrets.WAKATIME_API_KEY &#125;&#125; GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; SHOW_OS: &quot;False&quot; SHOW_PROJECTS: &quot;False&quot; SHOW_COMMIT: &quot;False&quot; SHOW_DAYS_OF_WEEK: &quot;False&quot; SHOW_TIMEZONE: &quot;False&quot; SHOW_EDITORS: &quot;False&quot; SHOW_SHORT_INFO: &quot;False&quot; SHOW_LOC_CHART: &quot;False&quot; SHOW_TOTAL_CODE_TIME: &quot;False&quot; SHOW_PROFILE_VIEWS: &quot;False&quot; 一些自定义配置可以在 waka-readme-stats 仓库中找到示例。 然后提交至仓库。 更新README.md文件，在需要展示的地方，添加如下代码，下面代码相当于占位符，生成后的数据统计会放置在这个位置之中。 12&lt;!--START_SECTION:waka--&gt;&lt;!--END_SECTION:waka--&gt; 点击该工作流，再点击Run workflow运行。 github actions 工作流是根据 .yml 配置文件定时运行任务，如果想马上看到结果，就需要手动执行一下 运行成功后可以点击当前的workflow进入查看执行日志。 以上配置完成后耐心等待数据同步到readme即可。 另外还可参考以下资料： https://blog.csdn.net/weixin_43233914/article/details/126087735 https://github.com/athul/waka-readme#extras https://github.com/anmol098/waka-readme-stats","categories":[{"name":"页面美化","slug":"页面美化","permalink":"https://chh3213.github.io/categories/%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://chh3213.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"Windows远程桌面工具连接Ubuntu系统","slug":"Windows远程桌面工具连接Ubuntu系统","date":"2022-10-18T06:32:01.000Z","updated":"2022-10-22T04:07:22.471Z","comments":true,"path":"2022/10/18/Windows远程桌面工具连接Ubuntu系统/","link":"","permalink":"https://chh3213.github.io/2022/10/18/Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5Ubuntu%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1. 前言1.1 常见远程桌面软件推荐随着过去一年多的研究生生涯，也陆陆续续用了几款远程桌面软件。目前来看都还不错。我主要用过的是4款：TeamViewer，RustDesk, 向日葵, ToDesk。这4款ubuntu和windows下均可使用。 4个软件的界面分别如下： 1.2 比较 其中，个人体验而言，TeamViewer，RustDesk,ToDesk是优于向日葵的。因为向日葵免费版不能够进行传输文件，剪贴板也不能共享（不能相互之间复制粘贴文字）。 速度而言，使用局域网时，体验上三者没有什么差别；不使用局域网连接时，向日葵速度&gt;TeamViewer&gt;RustDesk=ToDesk。所以，使用局域网时，还是推荐使用后三者的。不过可以自建服务器，不过我自己没有试过，还不懂咋搞。。。 使用向日葵可能会碰到的一个问题，就是远程连接Ubuntu时，一连接就秒断的问题。具体可参考这个。之前实验室的服务器就碰到了这个问题，折腾了很久都没解决，还差点把系统搞崩了，因此果断放弃在服务器上使用向日葵，转为使用后3种了。 2. 使用windows远程桌面连接ubuntu用过windows远程桌面连接的小伙伴们都知道，使用起来非常顺畅丝滑，界面清晰。但它只能在windows之间使用，远程连接ubutnu还需要进行一些配置。 2.1 安装xrdpXrdp 是一个微软远程桌面协议（RDP）的开源实现，它允许我们通过图形界面控制远程系统。这里使用RDP而不是VNC作为远程桌面，是因为Windows自带的远程桌面连接软件用的就是RDP协议，RDP在Windows下的体验非常好，包括速度很快（因为压缩方案做得比较好），可以直接在主机和远程桌面之间复制粘贴等等。 有的Xwindow软件是不太兼容xrdp的（比如ubuntu 18.04的默认桌面），但是ubuntu 20.04使用的Gnome是完全ok的。 安装过程如下： 1sudo apt install xrdp 安装完成xrdp 服务将会自动启动，可以输入下面的命令验证它： 1sudo systemctl status xrdp 可以将xrdp设为开机启动1sudo systemctl enable xrdp 默认情况下，xrdp 使用/etc/ssl/private/ssl-cert-snakeoil.key，它仅仅对ssl-cert用户组成语可读，所以需要运行下面的命令，将xrdp用户添加到这个用户组： 12sudo adduser xrdp ssl-cert sudo systemctl restart xrdp 然后使用Windows自带的远程桌面软件连接服务器IP地址或者域名就行了。 2.2 问题1：远程连接后出现黑屏==连接远程桌面输入账户和密码后，进入ubuntu20.04后，如果出现的是黑屏==，","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Remote","slug":"Remote","permalink":"https://chh3213.github.io/tags/Remote/"}]},{"title":"内网穿透工具——cpolar","slug":"内网穿透工具——cpolar","date":"2022-10-15T12:16:58.000Z","updated":"2022-10-25T07:16:57.826Z","comments":true,"path":"2022/10/15/内网穿透工具——cpolar/","link":"","permalink":"https://chh3213.github.io/2022/10/15/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94cpolar/","excerpt":"在之前介绍了SakuraFrp内网穿透工具，后来又发现了一个也比较好的内网穿透工具cpolar。","text":"在之前介绍了SakuraFrp内网穿透工具，后来又发现了一个也比较好的内网穿透工具cpolar。 打开官网后直接选择对应版本下载安装即可。 下面介绍windows下和ubuntu的安装。 ☺️windows 被控端安装在官网注册好账号后，到官方界面下载对应的安装包，解压后默认安装即可。cpolar安装后会默认安装两条样例隧道: 一个是Website隧道，指向http 8080端口 一个是远程桌面隧道（win系统），指向tcp 3389端口 因此，我们安装完成后，只需要启动远程桌面隧道服务，就可以获得公网地址。 浏览器访问127.0.0.1:9200，登录cpolar web-ui管理界面。点击左侧仪表盘——隧道管理——隧道列表，找到远程桌面隧道，点击启动该隧道 隧道启动成功后，点击左侧仪表盘——状态——在线隧道列表，找到远程桌面隧道，可以看到已经有生成了相应的公网地址，复制下来。 安装完成后，在另外一台windows电脑进行远程桌面连接，填入刚才生成的公网TCP端口地址（是tcp://后面的地址），就可以实现内网穿透远程桌面连接。 ☺️linux被控端安装当服务器为linux系统时，我们可以通过SSH远程连接，同样正常在服务器安装cpolar客户端，然后映射内网端口即可。 linux系统官网已经给了一键自动安装脚本 国内使用 1curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 国外使用 1curl -sL https://git.io/cpolar | sudo bash 注意root权限问题。 安装完成后，登录账号查看认证的token： 然后终端输入：1cpolar authtoken 输入token数字xxxxxxxxxxxxxxxxxx 如果需要配置cpolar开机自启动: 1sudo systemctl enable cpolar 启动服务时输入命令： 1sudo systemctl start cpolar 通过查看服务状态来检查是否启动成功： 1sudo systemctl status cpolar 如显示active，则说明已经启动成功。 关闭命令： 1sudo systemctl stop cpolar cpolar 卸载方法 1curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash -s -- --remove 1234cpolar默认安装路径 /usr/local/bin/cpolar,安装脚本会自动配置systemd服务脚本，启动以后，可以开机自启动。如果第一次安装，会默认配置一个简单的样例配置文件，创建了两个样例隧道，一个web，一个sshcpolar配置文件路径: /usr/local/etc/cpolar/cpolar.yml 启动成功后，登录cpolar官网后台查看状态，可以查看到所有在线隧道的公网地址，找到SSH隧道的公网地址，复制下来。 然后就可以使用ssh相关工具通过公网ip登录了。1ssh username@公网地址 -p 端口号如1ssh pi@1.tcp.vip.cpolar.cn -p 20013由于我们的本地22端口到了公网被映射到了20013端口，所以，ssh命令需要加-p参数，后面加公网隧道端口号。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://chh3213.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"内网穿透工具——SakuraFrp","slug":"SakuraFrp内网穿透工具","date":"2022-10-15T04:04:44.000Z","updated":"2022-10-28T12:20:52.904Z","comments":true,"path":"2022/10/15/SakuraFrp内网穿透工具/","link":"","permalink":"https://chh3213.github.io/2022/10/15/SakuraFrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/","excerpt":"SakuraFrp是一个内网穿透工具，使用它就可以轻松的实现在不是同一个局域网下的远程连接☺️。","text":"SakuraFrp是一个内网穿透工具，使用它就可以轻松的实现在不是同一个局域网下的远程连接☺️。 😋SakuraFrp简单介绍内网穿透的基本原理可以戳此处。 😋被控端电脑接入步骤😉Sakura frp账号注册首先在官网注册Sakura frp账号。注册完成后需要进行实名认证: 点击首页的这个地方可以查看访问密钥，这个密钥待会用得上，不能把访问密钥告诉给他人。 😉windows被控端设置点击穿透下的软件下载按钮 进入页面后，官方推荐的是直接下载启动器，因此我们直接下载启动器即可。 下载完成后，点击安装即可。安装完后打开，软件大概长这样。 将刚才网页上的访问密钥填入，登录即可。 登陆完成后，点左边菜单栏的隧道，点击+号，进行相应的填写。例如这样 需要注意的是隧道类型和穿透节点的选择。隧道类型选择TCP（想使用ssh方式，也是选择TCP），穿透结点选择一个可以用的就行，本地IP填写127.0.0.1即可。填写完成后点击创建，隧道就创建成功了。 隧道的创建也可以直接在网页上创建，然后在启动器中刷新即可。 最后，点击开启刚才的隧道，会弹出日志信息，记住这个日志信息上面的IP或者服务器域名，待会通过这个IP连接被控电脑： 至此，内网穿透全部搞定，被控电脑全部设置完毕。 😉远程连接被控端上面创建内网穿透的过程其实就是分配了一个公网IP，所以接下来我们可以通过这个公网IP来访问我们的电脑； win10提供了相当给力的远程连接工具：“远程桌面连接”。可以在windows系统之间进行远程控制。 如果没有启动远程桌面连接，那么按照下述步骤设置。 打开我的电脑，右键点击属性 选择远程设置 点击允许远程协助连接此计算机即可开启。 开启之后，打开远程桌面连接程序，直接电脑的左下角菜单栏搜索即可出来。填入内网穿透的地址、远程计算机账户名、密码(无密码留空)即可远程。 😉ubuntu被控端设置ubuntu被控端需要下载frpc客户端，点击穿透下的软件下载按钮，进入后选择linux系统 至于选择哪一个架构，可以在ubutnu系统中在终端使用命令查看： 1dpkg --print-architecture 或者使用1uname -m 详情可参考博客查看Linux系统架构的命令。我的是amd64，因此选择amd64点击右边的复制链接。 在终端使用下面的命令进入 /usr/local/bin 目录并下载文件,确保现在已经处于有 root 权限的环境下。 12345678910cd /usr/local/bin# 一般来说只需要使用这条命令:wget -O frpc &lt;下载地址&gt;# 如果上面的命令报错，请尝试这条:curl -Lo frpc &lt;下载地址&gt;# Linux frpc 通常已经过 UPX 压缩，如需下载未压缩的版本请在下载地址尾部加上 _noupx 然后设置权限并校验文件是否有损坏： 123chmod 755 frpcls -ls frpcmd5sum frpc 此时 frpc 就安装完成并可以正常使用了。可以用此命令查看 frpc 版本号：1frpc -v 😉ubutnu 使用 frpc通过上节安装完成后，在终端使用命令开启frpc，注意加root权限：1sudo frpc在 Token 后面的文本框内输入访问密钥，然后使用 Tab 键切换到 Login 按钮并按 回车 键登录 (若终端支持也可使用鼠标进行操作)： 登录成功后 TUI 会显示当前账户下的隧道列表，使用方向键选中想要启动的隧道，按空格标为绿色 (或使用鼠标直接点击隧道)： 可以一次性启用多个隧道，但是这些隧道必须位于同一节点下,也可以直接选中节点来启用该节点下的所有隧道 选择完毕后，即可启动隧道，相关启动参数会被保存到配置文件 frpc.ini 中，下次不带参数直接运行 frpc 时不再显示 TUI 而是直接启动隧道。 至此，ubuntu的被控端部分设置完毕，远程只需要填入得到的公网ip或者域名即可。 例如，隧道启动成功后，使用vscode的远程remote插件连接ssh，那么只需要打开 然后输入对应的ip和端口 如：1ssh YHS@2.tcp.vip.cpolar.cn -p 14884 YHS为被控电脑的用户名，2.tcp.vip.cpolar.cn为公网ip，14884为远程端口号。这样就可以连接上ssh了。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://chh3213.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"hexo+gitee/github进行博客搭建","slug":"hexo-gitee-github进行博客搭建","date":"2022-06-20T05:56:11.000Z","updated":"2023-12-28T03:14:28.192Z","comments":true,"path":"2022/06/20/hexo-gitee-github进行博客搭建/","link":"","permalink":"https://chh3213.github.io/2022/06/20/hexo-gitee-github%E8%BF%9B%E8%A1%8C%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"使用hexo工具和gitee/github搭建自己的博客。","text":"使用hexo工具和gitee/github搭建自己的博客。 1. 使用gitee（github）与hexo好处 gitee 是国内的网站，相较于 github 访问速度更快； github是国外的网站，可以写一些比如科学上网之类的博客不至于发布不了。 gitee和github免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； hexo是大家使用非常广泛的静态博客； Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. 安装2.1 安装NodejsHexo 依赖 Node.js 和 NPM包管理，Node.js 安装后会自带NPM。因此，只需安装好node.js即可。 不管是macOS还是Windows系统，直接去nodejs官网下载安装包下载安装即可，属于傻瓜式安装（点击下一步、下一步。。。）这里不过多介绍。 2.2 安装git由于后面我们需要用git管理仓库，所以这边需要安装git。方法也很简单，直接去官网下载即可，也属于傻瓜式安装。 安装完成后，你的右键菜单栏会出现这两个标签： 可以打开CMD，进入命令行，运行git命令看是否安装成功： 1git --version 能够输出版本号则表示正常。 2.3 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 注：npm管理工具在安装好nodejs后就会自带，所以不需要额外安装。 打开cmd命令行或者右键选择git bash here，输入： 1npm install -g hexo-cli 即安装成功。 3. 建站hexo安装完成后，即可开始初始化hexo项目，进行建站。 进入到你打算存放博客源代码的目录下，执行初始化命令： 1234# 初始化文件夹名为 hexo_bloghexo init hexo_blogcd hexo_blognpm install hexo_blog为存放博客的文件夹名字，你可以按照自己需求取，例如我这里取得就是hexo_blog。 初始化完成后，hexo_blog文件夹下的文件目录大致如下： 12345678910.├── _config.yml # 网站的配置信息├── node_modules # 应用依赖信息├── package-lock.json├── package.json # 依赖包├── scaffolds # 模板文件├── source # 资源文件夹是存放用户资源的地方│ ├── _drafts # 草稿文件夹，刚初始化时可能不存在│ ├── _posts # 文章/帖子源码列表└── themes # 博客主题 其中_config.yml文件是配置文件，以后需要经常打交道的。里面的各个参数可以参考网站。source文件夹是存放用户资源的地方，即以后你写的博客都存放在这里。 4. 启动初始化项目后默认会安装相关的依赖，接着在命令行输入如下命令即可在本地运行查看博客 ： 123456# 启动服务，默认端口为 4000，启动服务后可以在浏览器输入 `http://localhost:4000` 查看效果hexo server# 简写方式hexo s# 还可以使用 -p, 指定 8888端口hexo s -p 8888 5. 配置建站完成后我们需要进行 配置，hexo 中主要有两项配置。 站点配置文件，路径为 /_config.yml ； 主题配置文件 ，路径是 /themes/(自己下载的主题)/_config.yml 。 站点配置文件主要是有以下几个基础选项 12345678910111213# Hexo Configuration# 网站主标题，SEO元素之一title: blog# 网站副标题，可选subtitle:# 网站描述, SEO元素之一，用于告诉搜索引擎关于这个站点的描述description: # 网站的关键词keywords: # 网站作者author: chh3213# 网站使用的语言, 由于 Hexo 具备多语言配置，默认为英文，若需要中文语言，则修改如下language: zh-CN 其余配置，可以具体参考hexo的文档。 5.1 主题配置熟悉了博客系统的操作后，接下来就是美化博客。Hexo 支持主题，我们可以根据官网的创建主题教程自己来设计，也可以直接在主题商城 中找现成的主题。 例如，笔者这边选择了hexo-theme-yilia 主题配置很简单，进入hexo-theme-yilia 的仓库，复制git clone的地址。 然后在hexo_blog文件夹目录下，git bash中输入： 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题在hexo_blog文件夹目录下的 themes 里面，如图：然后在 站点配置文件(/_config.yml) 中修改里面的 theme: landscape 为 theme: yilia 。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 最后启动主题即可。 123hexo clean # 启动主题前需要清除缓存与已部署的文件hexo generate # 生成静态网页hexo s # 本地查看博客 6. 部署到gitee pages我们使用git进行部署，可以将网站部署至私人服务器、也可以部署到免费的github pages或者gitee pages上。这边笔者选择的是gitee pages，因为github pages有时候不用点科学手段进不去。。。 6.1 创建一个gitee仓库 注意：这里需要注意的一点是，如果你想直接通过域名就可以访问到你的博客个人网站，创建仓库的时候仓库名要和用户名保持一致。例如，我的gitee用户名为caohuanhui，我创建的仓库名是caohuanhui，那我访问的时候直接使用https://caohuanhui.gitee.io/就可以直接访问了。但是，如果我创建的仓库名和用户名不一样，比如我创建仓库的时候，仓库名为blog，那我访问的时候，就必须要域名+仓库名才能访问，如https://caohuanhui.gitee.io/blog。 至于是否选择开源，这边建议选择私有，因为这个仓库，还可以用来进行博客源代码备份，后面会提到。 点击创建即可，成功创建一个gitee仓库。 6.2 配置路径 进入刚创建的仓库，点击 克隆/下载，复制 Https 地址 ==注==：这边并没有强制要求选择https方式，选择ssh方式也是可以的。 打开博客根目录，修改_config.yml 文件主要修改以下内容： 1234deploy: type: git repository: https://gitee.com/caohuanhui/caohuanhui.git # 刚才复制的 Https 地址 branch: pages # 部署到 pages 分支，如果该分支不存在，就会自动创建它 接下来我们还需要安装一个插件，在 git bash 下输入 1npm install hexo-deployer-git --save 如果我们没有安装这个插件，此时直接执行部署的命令 hexo g -d 的话一般会报如下错误： 1Deployer not found: gitee 或者 Deployer not found: git 6.3 开启GiteePages服务进入到刚才创建的gitee仓库，找到服务，点击Gitee Pages开启GiteePages服务 如果第一次开启Gitee Pages服务，会让你上传身份证进行验证，验证通过后即可使用。 进入到页面之后，选择GiteePages服务需要部署的分支，例如我这里要部署的分支为pages。推荐勾选上强制使用HTTPS，选择完毕之后点击启动（更新）便可开启GiteePages服务。 接着开始部署。如果你还没配置git账号的话，会提示你输入账号密码，输入正确的账号密码后就部署成功了。 1hexo g -d 每次部署成功后，都需要到GiteePages上点击更新。 6.4 github pages部署如果使用github pages，则步骤 类似。 在 GitHub 新建一个名称为 {username}.github.io的仓库，username是你的github用户名 打开根目录下的 _config.yml 文件，找到 Deployment ，修改如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/CHH3213/CHH3213.github.io.git branch: master 与giteePages 完全一致，只是地址不同，以及branch这里一定要是master分支。 启动GitHub Pages 在博客仓库的Settings界面，下拉找到GitHub Pages，生成博客网址部署成功后就可以通过https://{github用户名}.github.io/ 访问个人博客了 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而笔者所使用的是User Pages。简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 6.4. 博客源代码备份至于上述博客源代码的备份（即hexo_blog文件夹下的备份），笔者同样使用的是gitee仓库。 为了高效利用之前创建的部署gitee pages的仓库，所以这边并没有再额外创建一个仓库存放源代码，而是创建了两个分支，一个分支（hexo）用来存放源代码，一个分支（pages）用来存放博客部署后生成的文件，其中，存放博客源代码文件的分支设为主分支，如下图所示。 然后只需要通过一系列git操作，将本地源代码上传至仓库的hexo分支即可（这部分git基础操作就不在这介绍了）。 7. 写作一般我们都会使用 hexo new &lt;title&gt; 来建立文章，这种建立方法会将新文章建立在 source/_posts 目录下，当使用 hexo generate 命令编译 时，会将其 HTML 结果编译在 public 目录下，之后 hexo deploy 将会把 public 目录下所有文章部署到 GitHub，这是整个 Hexo 流程。 这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 hexo deploy 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。 笔者个人的写作习惯是： 创建草稿 (drafts ) 在草稿上进行写作 整理细节并在本地服务器上查看效果(server) 发布至正式的帖子上 生成静态文件并部署 7.1 创建草稿12# hexo new draft &lt;title&gt;hexo new draft 博客名称 Hexo 提供 draft 机制，它将新文章将建立在 source/_drafts 目录下。生成的文件博客名称.md 是一个 markdown 文件，默认的草稿模板内容如下： 1234---title: 博客名称tags: --- 在/scaffolds目录下可以修改draft、page、post(草稿、主页面、发布的文章)的模板。 7.2 在本地服务器预览草稿1hexo s --draft Hexo 的 Hexo server 另外提供 --draft 参数，这让我们可以达到一边编辑 markdown 文章，一边使用浏览器预览的目的。 7.3 发布草稿如果我们在本地服务器上校对完草稿细节后，可以将草稿发布为文章，否则在后续生成博客静态文件时不会被打包出来： 12# hexo publish [layout] &lt;filename&gt;hexo publish post 博客名称 输入命令后你可以发现发布的文章被转移到了source/_posts/上，这样就完成了本地的文章发布。 7.4 生成静态文件并部署 Hexo框架的一项工作就是将源文件 markdown 最后生成为 HTML： 123456# 生成文件hexo g# 监控文件变化，并生成静态文件hexo g --watch# 生成文件并部署hexo g -d 以上便是完整的部署过程了！ 8. 常用hexo命令12345678hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清楚缓存 缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： 123hexo s -g #生成并本地预览hexo g -d #生成并部署hexo clean &amp; hexo generate &amp; hexo server #重新生成并本地预览 参考资料 https://hexo.io/zh-cn/docs/ https://su-lemon.gitee.io/post/5bd42e8c.html https://developer.aliyun.com/article/794909 Gitee+Hexo配置个人博客中的坑 nexmoe官方教程","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://chh3213.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://chh3213.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"博客主页美化","slug":"博客主页美化","date":"2022-06-12T05:17:24.136Z","updated":"2023-12-28T03:28:38.661Z","comments":true,"path":"2022/06/12/博客主页美化/","link":"","permalink":"https://chh3213.github.io/2022/06/12/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96/","excerpt":"搭建的hexo博客的美化技巧。","text":"搭建的hexo博客的美化技巧。 除了主题自带的技巧外，这边再总结一些我用到的技巧。参考资料： https://juejin.cn/post/6997775533840793614#heading-15 文章封面生成随机图片使用: 只要请求图片时, 将路径改为API提供的路径即可. 对于Markdown来说: 1![image_infp](API_URL) 对于HTML来说是修改src属性: 1&lt;img src=&quot;API_URL&quot; /&gt; 但是仅仅这样做会出现一个问题: 当前页面使用同一个api链接的文章, 图片显示的都是同一张!(说好的随机呢?) 问题就出现在, 发起请求时, 由于链接地址是同一个, 实际上即使同一个页面中有多个(相同)图片链接, 也仅仅发起一次请求, 所以也就返回一张图片了! 所以只要修改链接不同即可! 以本博客使用到的api为例: http://api.mtyqx.cn/tapi/random.php 可以在末尾添加?x, 其中x是一个数字, 如: http://api.mtyqx.cn/tapi/random.php?54615 此时这是两个完全不同的请求, 所以显示的图片即为不同了! 附随机图片的一些API 二次元: https://img.paulzzh.tech/touhou/random 二次元: http://www.dmoe.cc/random.php 二次元：http://api.mtyqx.cn/tapi/random.php 添加动漫人物(看板娘)Hexo博客本身支持看板娘的，三步即可。 第一步，在主目录下执行命令： 1npm install --save hexo-helper-live2d 第二步，同样在主目录下执行： 1npm install live2d-widget-model-shizuku live2d-widget-model-shizuku是可选项。可选的模型如下： 123456789101112131415161718192021live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-harulive2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 第三步，在根目录配置文件（_config.yml）中添加如下代码： 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 然后重新部署即可。 hexo博客本身看板娘角色比较单调，stevenjoezhang大佬写了一个可以说话，可以换装的看板娘项目并开源，使用起来也是非常的方便。下面是Nexmoe主题下的安装步骤。 下载大神的仓库live2d-widget到主目录\\themes\\nexmoe\\source下，修改live2d-widget目录下的autoload.js文件中的路径 123// 注意：live2d_path 参数应使用绝对路径//const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;;const live2d_path = &quot;/live2d-widget/&quot;; 往\\themes\\nexmoe\\layout\\_partial\\_post目录下的header.ejs添加以下代码(在第一个div标签内): 123// 注意：live2d_path 参数应使用绝对路径//const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;;const live2d_path = &quot;/live2d-widget/&quot;; 在根目录配置文件（_config.yml）中添加如下代码： 12live2d: ##自定义看板娘动画 enable: true 然后重新部署即可。想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 和 waifu.css。其实看板娘可以侧边隐藏，对样本的修改影响也不大。 添加评论本篇博客使用的主题是nexmoe主题，它的配置评论的方式如下（gitalk为例）： 在GitHub上申请OAuth application 点击生成后，记住Client ID和 Client Secret 在themes文件夹下的_config.nexmoe.yml文件中，把刚才的Client ID和 Client Secret填在下面方框： 12345678910111213141516slotComment: &#x27; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;const gitalk = new Gitalk(&#123; clientID: &quot;&quot;, clientSecret: &quot;&quot;, repo: &quot;CHH3213.github.io&quot;, owner: &quot;CHH3213&quot;, admin: &quot;CHH3213&quot;, id: decodeURI(window.location.pathname) &#125;);gitalk.render(&quot;gitalk-container&quot;)&lt;/script&gt;&#x27; 即下图所示：文章代码中出现过这两个链接 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt; 这两个链接指引的文件是配置gitalk的代码，可以下载后保存于自己的网站并修改文章中的链接，获得相同的效果。 然后配置完成后，在需要开启评论框的文章中，开启评论：comments: true即可。 最后，hexo g -d部署生成后登录评论框初始化即可。 nexmoe主题的评论已经支持了任何评论系统，在themes/nexmoe/layout/post.ejs文件中可以看到，它是这么开启的 添加页面点击出现爱心特效 在 themes/你选择的主题/source/js 下新建文件 heart.js文件 ，添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586!(function (e, t, a) &#123; function n() &#123; c( &quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot; ), o(), r(); &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, (d[e].scale += 0.004), (d[e].alpha -= 0.013), (d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;)); requestAnimationFrame(r); &#125; function o() &#123; var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e); &#125;; &#125; function i(e) &#123; var a = t.createElement(&quot;div&quot;); (a.className = &quot;heart&quot;), d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s(), &#125;), t.body.appendChild(a); &#125; function c(e) &#123; var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try &#123; a.appendChild(t.createTextNode(e)); &#125; catch (t) &#123; a.styleSheet.cssText = e; &#125; t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a); &#125; function s() &#123; return ( &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; ); &#125; var d = []; (e.requestAnimationFrame = (function () &#123; return ( e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60); &#125; ); &#125;)()), n();&#125;)(window, document); 在themes/你选择的主题/layout/layout.ejs文件的body标签内添加： 12&lt;!-- 页面点击小红心-- 20221025--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/heart.js&quot;&gt;&lt;/script&gt; 重新部署生成后，即可出现特效。 1hexo clean &amp; hexo generate &amp; hexo server 浏览器网页标题特效 当用户访问你的博客时点击到了其他网页，我们可以让网页标题产生特效，呼唤用户回来，首先在目录 themes/你选择的主题/source/js 下新建一个 funnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617&lt;!--浏览器搞笑标题--&gt;var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヽ(●-`Д´-)ノ我在这等你！&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/trhx2.png&quot;); document.title = &#x27;ヾ(Ő∀Ő3)ノ谢谢你回来！&#x27; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 在themes/你选择的主题/layout/layout.ejs文件的body标签内添加： 12&lt;!--搞笑title--&gt;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/funnyTitle.js&quot;&gt;&lt;/script&gt; 重新部署即可。 添加代码块复制功能博客主题本身并没有集成代码块复制功能，因此这里给主题添加这个功能。 此方法对所有没有代码块复制功能的主题都有效，基于 https://github.com/zenorocha/clipboard.js 实现. 参考博客。 下载js文件保存到themes/你的主题/source/js目录下，重命名为clipboard-min.js。 在themes/你的主题/source/js目录下，创建clipboard-use.js，文件，添加内容如下： 123456789101112131415161718192021222324252627282930313233$(&quot;.highlight&quot;).wrap(&quot;&lt;div class=&#x27;code-wrapper&#x27; style=&#x27;position:relative&#x27;&gt;&lt;/div&gt;&quot;);/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function () &#123; var copyHtml = &#x27;&#x27;; copyHtml += &#x27;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&#x27;; copyHtml += &#x27; &lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&#x27;; copyHtml += &#x27;&lt;/button&gt;&#x27;; $(&quot;.highlight .code&quot;).before(copyHtml); var clipboard = new ClipboardJS(&#x27;.btn-copy&#x27;, &#123; target: function (trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on(&#x27;success&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制成功&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); clipboard.on(&#x27;error&#x27;, function (e) &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制失败&lt;/span&gt;&quot; setTimeout(function () &#123; e.trigger.innerHTML = &quot;&lt;i class=&#x27;fa fa-clipboard&#x27;&gt;&lt;/i&gt;&lt;span&gt;复制&lt;/span&gt;&quot; &#125;, 1000) e.clearSelection(); &#125;); &#125; initCopyCode();&#125;(window, document); 因为css的”子绝父相”在父元素有滚动条的情况下子元素会跟随父元素滚动，所以使用 hexo添加复制代码块的功能的代码会有代码块横向超出时出现“bug”的情况，解决方案是使用js动态给代码块元素添加父元素(相对定位)作为复制按钮子元素的定位参照父元素，而代码块元素则起到滚动元素的作用。即上文代码中的第一行代码。 clipboard提供了复制成功/失败(success/error)后的自定义事件触发，故可以通过这两个方法修改按钮文字，再通过setTimeout()方法在复制1s后再次显示“复制” 在themes/你的主题/source/css/style.css或者themes/你的主题/source/css/style.styl 样式（有的主题是css格式，有的是styl格式，差别并不大。）中添加如下代码： 1234567891011121314151617181920212223242526272829303132333435//代码块复制按钮.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px&#125;.code-wrapper:hover .btn-copy &#123; opacity: 1; z-index: 100;&#125; 引用js文件，将以下代码加入到你的layout布局文件（例如，nexmoe主题是在themes/你的主题/layout/layout.ejs文件）的body标签内： 123&lt;!-- 代码块复制功能,注意src路径 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/clipboard-min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/clipboard-use.js&quot;&gt;&lt;/script&gt; 当然将 clipboard-min.js 和 clipboard-use.js 保存到CDN上，通过远程引用也可以. 最后重新部署即可。 代码块高亮在nexmoe主题中，使用hexo原生的hightlight并没有起作用，根据官网教程，这里给出两种方法进行代码块的高亮。 使用prismjs进行代码高亮Prism是一种轻量级的，可扩展的语法突出显示工具，在构建时考虑了现代Web标准。 进入prismjs官网，依据情况选择主题、语言和最下方的插件。 其中语言我全部勾选了，插件如图所示选择了两个。选择完成后点击下方的下载按钮，分别下载css和js文件。下载后的文件可以保存在themes/你的主题/source/js文件夹下。 下载完成后，引入css文件和js文件即可。打开themes/你的主题/layout/layout.ejs文件（部分主题可能是swig格式），在head标签内添加css文件链接： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/prism.css&quot;&gt; 其中href后面填写的就是你下载的css文件的路径。假如你放在了themes/你的主题/source/js文件夹下，那么引入方式为： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/js/prism.css&quot;&gt; 即下图： js文件的引入类似，也是在这个文件中，但是此时是在body标签内引入。 1&lt;script src=&quot;/js/prism.js&quot; async&gt;&lt;/script&gt; 即下图： 同理，src是你的路径。 在完成上述步骤后，在博客的配置文件_config.yml中配置： 12345678highlight: enable: falseprismjs: enable: true preprocess: true line_number: true line_threshold: 0 tab_replace: &#x27;&#x27; 最后重新编译即可。 使用hightlight.js进行代码高亮使用hightlight.js配置的方式与prismjs类似。 首先前往hightlight.js下载页面，勾选常用语言后，下拉点击Download按钮 将下载后的文件解压在themes/你的主题/source/js文件夹下。 打开themes/你的主题/layout/layout.ejs文件，在body标签内引入： 1&lt;script src=&quot;/js/highlight/highlight.min.js&quot;&gt;&lt;/script&gt; 即下图： 注意src是你存放的路径。 然后，打开hightlight/styles/文件夹，里面有很多css主题样式，选择一个你想要的主题，例如，我选择的是atom-one-dark.min.css样式，那么就在layout.ejs文件下的head标签内引入： 1&lt;link href=&quot;/js/highlight/styles/atom-one-dark.min.css&quot; rel=&quot;stylesheet&quot;&gt; 即下图： 最后，在博客配置文件_config.yml中配置： 1234567highlight: enable: true line_number: true auto_detect: true tab_replace: &#x27;&#x27; wrap: true hljs: true 编译部署后即可生效。 Sakana石蒜模拟器偶然在网上发现了这个非常可爱有趣的小动态玩偶，现在把它集成到网站上去，简易集成可参考博客。 打开themes/你的主题/layout/layout.ejs文件，在body标签内引入： 12345678910111213141516171819&lt;!--sakana模拟器--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;&lt;style&gt; html &#123; background: #CCC; &#125; html .sakana-box &#123; position: fixed; right: 0; bottom: 0; transform-origin: 100% 100%; /* 从右下开始变换 */ &#125;&lt;/style&gt;&lt;div class=&quot;sakana-box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sakana@1.0.8&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/sakana.js&quot;&gt;&lt;/script&gt; 在themes/你的主题/source/js文件夹下新建sakana.js文件，填写内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//设置sakana状态// 设定静音Sakana.setMute(true);// 获取静音状态const &#123; isMute &#125; = Sakana.Voices;// 启动const sakana = Sakana.init(&#123; // 选项: 默认值 el: &#x27;.sakana-box&#x27;, // 启动元素 node 或 选择器 character: &#x27;chisato&#x27;, // 启动角色 &#x27;chisato&#x27;,&#x27;takina&#x27; inertia: 0.1, // 惯性 decay: 0.99, // 衰减 r: 60, // 启动角度 y: 10, // 启动高度 scale: 0.5, // 缩放倍数 translateY: 0, // 位移高度 canSwitchCharacter: false, // 允许换角色 onSwitchCharacter(character)&#123; // 切换角色回调 console.log(`$&#123;character&#125; dayo~`); &#125;,&#125;);// 设定归零角度sakana.setOriginRotate(10);// 获取角色运行状态const v = sakana.getValue();// 确保运行sakana.confirmRunning();// 切换角色sakana.switchCharacter();// 暂停动作sakana.pause();// 恢复动作sakana.play();// 切换特定角色sakana.setCharacter(&#x27;chisato&#x27;); 博客重新部署生成即可。 使用不蒜子添加访问量和阅读量功能添加访问量等信息以nexmoe主题为例，打开themes/nexmoe/layout/_partial/header.ejs文件，在&lt;div class=&quot;nexmoe-copyright&quot;&gt;标签内添加以下代码即可： 12345678&lt;!-- 添加访问数 --&gt; &lt;div style=&quot;font-size: 13px&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://widget.heweather.net/standard/static/css/he-standard.css?v=1.4.0&quot;&gt; &lt;script src=&quot;https://widget.heweather.net/standard/static/js/he-standard.js?v=1.4.0&quot;&gt;&lt;/script&gt; &lt;script async=&quot;&quot; src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 本站总访问量 &lt;a id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/a&gt; 次&lt;br&gt; 本站访客数&lt;a id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/a&gt;人次 &lt;/div&gt; 重新部署即可生效。 添加文章阅读量信息以nexmoe主题为例，打开themes/nexmoe/layout/_partial/_post/word-count.ejs文件，添加以下代码即可： 123&lt;a&gt;&lt;i class=&quot;nexmoefont icon-areachart&quot;&gt;&lt;/i&gt; &lt;span class=&quot;archive-article-date&quot;&gt;阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 添加位置如下： 重新部署即可生效。 后来测试发现好像并不是每篇文章的阅读量，是总的阅读量，暂且先这样。 添加文章分享链接在themes/nexmoe/layout/_partial/copyright.ejs中，添加： 1234&lt;!-- 文章分享 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css&quot;&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;social-share&quot; data-mode=&quot;prepend&quot; data-disabled=&quot;tencent,diandian&quot;&gt;&lt;/div&gt; 添加位置如下： 重新部署即可生效。 博客添加pdf 插件一、安装插件1npm install --save hexo-pdf 二、配置 在你需要引用的md文件中添加pdf链接 外部链接：1&#123;% pdf &lt;http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf&gt; %&#125;本地连接：1&#123;% pdf 路径+名字.pdf %&#125;例如，我是在study文件夹下index.md文件中引用了pdf文件夹下的career.pdf文件 那么就应该这么引用：1&#123;% pdf ../pdf/career.pdf %&#125; 数学公式支持参考：https://myblackboxrecorder.com/use-math-in-hexo/","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://chh3213.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"页面美化","slug":"页面美化","permalink":"https://chh3213.github.io/categories/%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://chh3213.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"美化","slug":"美化","permalink":"https://chh3213.github.io/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"ubuntu20.04配置Qv2ray","slug":"ubuntu20-04配置Qv2ray","date":"2022-04-15T14:48:35.000Z","updated":"2023-12-28T02:46:26.883Z","comments":true,"path":"2022/04/15/ubuntu20-04配置Qv2ray/","link":"","permalink":"https://chh3213.github.io/2022/04/15/ubuntu20-04%E9%85%8D%E7%BD%AEQv2ray/","excerpt":"","text":"参考资料：Ubuntu20.04下成功配置Qv2ray 1. 安装客户端软件中心搜索qv2ray安装即可 2. 配置客户端2.1 软件配置打开Qv2ray, 会在主文件夹下的snap下自动生成一个名为qv2ray的文件夹 进入https://github.com/v2ray/v2ray-core/releases ，根据自己的系统下载相应的核心文件，我这边下载的是v2ray-linux-64.zip 而后在目录/home/your_user_name/snap/qv2ray/4576/.config/qv2ray文件夹下新建vcore文件夹，并将之前下载的核心文件解压缩后全部拷贝到vcore文件夹内。注意这里的4576版本号是不固定的，根据自己的来就好。另外就是需要按住ctrl+h才能显示隐藏的.config文件夹。 以上完成后验证核心文件。点击Qv2ray界面中的首选项： 然后点击内核设置—&gt;检查V2Ray核心设置： 如果一切正常，则会出现检查通过提示： 然后便可以点击OK，关闭。除此之外，还需配置网络代理，首先查看入站设置中的默认网络代理： 例如我这里默认的是socks端口为7891,http端口为7890.这个端口号是可以修改的，这里用默认的就行。随后，ubuntu桌面右上角打开ubuntu的系统设置，选择网络—&gt;网络代理 将网络代理切换为手动，如图所示，将HTTP和HTTPS代理端口填写为上面获取到的HTTP端口，Socks主机端口号也填写成上面获取到的端口号即可。 这一部分配置完成。 注：默认端口号是可以更改的，只需要让软件中的端口号和ubuntu系统设置中的网络代理端口号保持一致，即可。 2.2 node配置回到软件首页配置入网config文件。选择新建,出现如下信息： 我们需要将获取到的node复制粘贴到所述的分享链接框内即可。至于节点的获取，在这里分享一个github上的free获取地址：free node导入node后，就会出现类似如图所示的界面： 双击任何一个node，即可连接成功。如果不需要连接时，点击断开连接以及将ubuntu系统中的网络代理从手动切换为禁用。最后祝小伙伴们使用愉快。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"https://chh3213.github.io/tags/VPN/"}]},{"title":"windows下配置Qv2ray","slug":"windows下配置Qv2ray","date":"2022-04-15T14:45:54.000Z","updated":"2023-12-28T02:49:52.112Z","comments":true,"path":"2022/04/15/windows下配置Qv2ray/","link":"","permalink":"https://chh3213.github.io/2022/04/15/windows%E4%B8%8B%E9%85%8D%E7%BD%AEQv2ray/","excerpt":"","text":"参考资料Windows下成功配置Qv2ray 1. 软件下载点击https://github.com/Qv2ray/Qv2ray/releases，根据自己系统选择对应的下载，我这边选的是 2. 配置核心文件点击https://github.com/v2fly/v2ray-core/releases，根据你自己的环境选择对应的压缩包下载，成功后先从桌面打开qv2ray, 进入界面后在设置里根据提示的核心文件路径进行配置。 ! 根据路径提示需要有一个名为vcore的文件夹，因此这里必须在相应路径下新建该文件夹。vcore文件夹新建好之后需要将刚才下载的压缩包里的核心文件拷贝过来。 接着通过核心验证。 3. node配置回到软件首页，选择导入,出现如下信息： 我们需要将获取到的node复制粘贴到所述的分享链接框内即可。至于节点的获取，在这里分享一个github上的free获取地址：free node导入node后，就会出现类似如图所示的界面： 双击默认分组，可以看到所有节点 双击任何一个node，即可连接成功。如果不需要连接时，点击断开连接即可。最后祝小伙伴们使用愉快。","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"https://chh3213.github.io/tags/VPN/"}]}],"categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://chh3213.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/categories/AI/"},{"name":"VPN教程","slug":"VPN教程","permalink":"https://chh3213.github.io/categories/VPN%E6%95%99%E7%A8%8B/"},{"name":"页面美化","slug":"页面美化","permalink":"https://chh3213.github.io/categories/%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://chh3213.github.io/categories/Ubuntu/"},{"name":"hexo博客","slug":"hexo博客","permalink":"https://chh3213.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://chh3213.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"AI","slug":"AI","permalink":"https://chh3213.github.io/tags/AI/"},{"name":"clash","slug":"clash","permalink":"https://chh3213.github.io/tags/clash/"},{"name":"chatgpt","slug":"chatgpt","permalink":"https://chh3213.github.io/tags/chatgpt/"},{"name":"美化","slug":"美化","permalink":"https://chh3213.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Remote","slug":"Remote","permalink":"https://chh3213.github.io/tags/Remote/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://chh3213.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"博客","slug":"博客","permalink":"https://chh3213.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"VPN","slug":"VPN","permalink":"https://chh3213.github.io/tags/VPN/"}]}